# プロジェクトガイドライン

## 指示
- あなたはプロのWebプログラマです。
- コンポーネントや関数は役割や責務に応じて適宜切り出してください。
- 不明点があったら作業を止めて質問してください。
- 保守しやすいように処理についてのコメントを残してください。

## サービス名
- LYNX

## サービス概要
ブロガーやアフィリエイター、自社のメディアサイトを運営しているWebマーケター向けのサイト管理ツールです。
主に記事同士の内部リンクの関係性を可視化・管理するためのツールです。

## システム構成
- フロントエンド
  - TypeScript
  - [ReactRouter v7](https://reactrouter.com/home)
  - [shadcn/ui](https://ui.shadcn.com/)
  - ReactHookForm
  - zod
  - react-icons
  - tailwindcss

- バックエンド
  - TypeScript
  - NestJS
  - Prisma
  - PostgreSQL

- スクレイピング用APIサーバー
  - Python
  - Scrapy
  - FastAPI

## 機能
### GoogleのOAuth認証
- Googleアカウントを利用したログイン・会員登録

### Webサイトのスクレイピングとコンテンツ情報の取得
- Webサイトの情報をスクレイピング・取得して編集・DBに保存する

### ダッシュボード
- DBから取得したWebサイトのコンテンツ情報の分析レポートを表示

### 内部リンク相関表
- 記事内の内部リンクの相関表をマップで表示し、視覚的にどの記事に内部リンクがある/ないのか判断する

## 実装方針
UIコンポーネント作成時は、基本的に`shadcn/ui`のコンポーネントを利用してください。
また、コンポーネントの再利用性を高めるために、コンポーネントのスタイルは`tailwindcss`を利用してください。
`shadcn/ui`に適切なコンポーネントがない場合は、他のコンポーネントライブラリを利用して構いません。
ただし、バンドルサイズが巨大になりすぎないように、適切なコンポーネントライブラリを選定してください。

Remix + Reactベストプラクティス要件
以下のベストプラクティスに従って実装してください:
1. Remixアーキテクチャの最適活用

ルート構造とネスト: 適切なルートモジュールの構造とネスト関係を設計し、共通UIの重複を避ける
ローダー/アクション分離: loaderとaction関数を明確に分離し、サーバーサイドのデータフェッチングと変更処理を実装
エラーバウンダリ: ErrorBoundaryコンポーネントを適切に実装して、ユーザーフレンドリーなエラー処理を行う
メタデータ: meta関数を使用したSEO対応と適切なメタタグ管理
リソースルート: 適切な場所で.serverファイルやリソースルートを使用してクライアントバンドルを最適化

2. データフローの最適化

プログレッシブエンハンスメント: JavaScriptなしでも基本機能が動作するフォームとリンク
最適化されたフェッチ: 必要なデータのみをフェッチし、useRevalidatorやuseFetcherを適切に活用
ネストデータ: 親ルートから子ルートへのデータ共有にuseMatchesを活用
キャッシュコントロール: 適切なキャッシュヘッダーとキャッシュ戦略を実装
並行データロード: 可能な限りPromise.allを使用して並行データロード

3. フォームとミューテーション

プログレッシブフォーム: 標準的なHTMLフォームをベースにし、<Form>コンポーネントで拡張
検証: サーバーサイド検証とクライアントサイド検証の適切な組み合わせ
インテント: 単一アクションで複数のインテントを処理（RESTful設計）
最適化されたUX: useFetcherを使った楽観的UI更新とuseNavigationでのローディング状態管理
エラーハンドリング: フォームエラーの適切な表示と処理

4. コンポーネント設計原則

コンポジション: 単一責任の原則に基づく小さな専門的コンポーネント
プレゼンテーションとコンテナ: UI表示とデータ/ロジック処理の分離
再利用性: プロジェクト全体で再利用可能なコンポーネントの設計
パフォーマンス: メモ化（React.memo, useMemo, useCallback）の適切な使用
完全型付け: TypeScriptによる厳格な型定義（propsのインターフェース定義含む）

5. サーバー/クライアント分離

境界の明確化: サーバーコードとクライアントコードの明確な分離
セキュリティ: 敏感なロジックは.server.tsに配置
ハイドレーション: クライアントハイドレーションの問題を避ける（Suspense活用等）
環境変数: サーバー環境変数とクライアント環境変数の適切な扱い
サーバーリソース: データモデルとDBアクセスを適切に抽象化

6. パフォーマンスとUX

ストリーミング: UI部分のストリーミングにdeferとAwaitを活用
Suspense: 非同期のデータロードとコード分割にSuspenseを活用
正しいステータスコード: 適切なHTTPステータスコードを返す
プリフェッチ: パフォーマンス向上のためにプリフェッチを実装
Bundle分析: クライアントバンドルサイズを最小化する設計

7. テスト容易性

コンポーネントテスト: React Testing Libraryを使った孤立テスト
統合テスト: CypressやPlaywrightを使ったE2Eテスト対応
モック戦略: サーバー依存を適切にモック化

出力フォーマット
以下のファイル構造で実装を提供してください:

ルートモジュール (app/routes/path/to/route.tsx) - loaderとactionを含む
Reactコンポーネント (app/components/ComponentName.tsx)
サーバーモデル (app/models/resource.server.ts) - 必要な場合
ユーティリティ関数 (app/utils/helpers.ts) - 必要な場合
スタイル定義 - 選択したCSSアプローチに応じたファイル
テスト (app/components/ComponentName.test.tsx) - オプション

各ファイルは完全な実装を含み、省略部分なく動作可能なコードとしてください。