# **React Router v7 コーディング規約**

## **はじめに (Introduction)**

### **本規約の目的と適用範囲 (Purpose and Scope of These Conventions)**

本規約は、React Router v7 を利用するプロジェクトにおいて、コードの一貫性を保ち、保守性を高め、最新のベストプラクティスを遵守することを目的としています。React Router v7 が提供する主要な機能とAPIに基づき、具体的なコーディング標準を提示することで、開発者が効率的かつ効果的にルーティング機能を実装できるよう支援します。

本規約の対象読者は、React Router v7 を用いてウェブアプリケーションを開発するすべての開発チーム及び個人開発者です。プロジェクトの規模や特性に応じて適用範囲を調整することも可能ですが、原則として本規約に準拠することが推奨されます。

### **React Router v7 の主要モード概要と比較 (Overview and Comparison of React Router v7 Modes)**

React Router v7 は、React 18からReact 19への移行期におけるニーズに応えるべく設計された、多戦略対応のルーティングライブラリです 1。開発者は、アプリケーションの要件やチームの志向に応じて、主に3つの異なる使用方法（モード）から最適なものを選択できます。これらのモードは、宣言的モード (Declarative Mode)、データモード (Data Mode)、そしてフレームワークモード (Framework Mode) です 1。

各モードは、ルーティングの定義方法、データハンドリングの仕組み、そして提供される機能セットにおいて特徴が異なります。プロジェクトの初期段階で適切なモードを選択することは、開発効率、アプリケーションのパフォーマンス、そして将来的な拡張性に大きな影響を与えるため、慎重な検討が求められます。

* 宣言的モード (Declarative Mode):  
  このモードは、従来の React Router の利用方法に最も近いアプローチを取ります。ルーティングの定義は、主に \<Routes\> および \<Route\> といったJSXコンポーネントを用いて宣言的に行われます。シンプルで直感的なため、React のコンポーネントベースの設計思想と親和性が高いと言えます。しかしながら、React Router v7 の主要な進化点である loader によるデータローディングや action によるデータ送信といった高度なデータ管理機能は、このモードの \<Route\> コンポーネントでは直接サポートされていません 2。これらの機能を利用するには、別途状態管理ライブラリや useEffect フックなどを組み合わせたカスタム実装が必要となる場合があります。そのため、宣言的モードは、比較的小規模なシングルページアプリケーション (SPA) や、静的なコンテンツが中心のウェブサイト、あるいはデータフェッチ戦略をルーティング定義から意図的に分離したい場合に適しています。  
* データモード (Data Mode):  
  データモードは、データ駆動型のアプリケーション開発を強力にサポートするよう設計されています。ルーティングの定義は、createBrowserRouter (または createHashRouter, createMemoryRouter) といったルーター作成関数に、ルートオブジェクトの配列を渡すことで行います 1。このルートオブジェクトには、パス情報やレンダリングするコンポーネントに加え、loader 関数 (データ取得) や action 関数 (データ変更) を直接定義できます。これにより、ルートとデータ操作ロジックが密接に連携し、コンポーネントはデータの取得方法を意識することなく、受け取ったデータを表示することに集中できます。エラー処理もルートオブジェクトレベルで設定可能です（ただし、errorElement の具体的な仕様は提供情報からは限定的です 3）。コード分割は、ルートオブジェクトの lazy プロパティを通じてサポートされます 3。データモードは、クライアントサイドで複雑なデータインタラクションを持つSPAの開発に適しています。  
* フレームワークモード (Framework Mode):  
  フレームワークモードは、Remix の設計思想を色濃く反映し、より統合的で規約に基づいた開発体験を提供します 1。ルーティングは、通常 app/routes.ts という設定ファイルで定義され、各ルートは対応するルートモジュール (例: app/routes/some-feature.tsx) と紐付けられます。このモードの最大の特徴は、サーバーサイドレンダリング (SSR) やプリレンダリング、ファイルシステムベースのルーティング、そしてルート単位での自動コード分割といった高度な機能が標準でサポートされている点です 1。loader や action はサーバーサイドで実行されることを前提として設計されており、クライアントバンドルから自動的に削除されるため、サーバー専用APIの安全な利用やバンドルサイズの最適化に貢献します。このモードは、パフォーマンスと開発効率を高度に両立させたい大規模アプリケーションや、フルスタックに近い開発スタイルを志向する場合に最適な選択肢となります。

プロジェクトの要件、チームのスキルセット、そして将来の展望を総合的に評価し、これらのモードから最適なものを選択することが、React Router v7 を最大限に活用するための第一歩です。モード選択の判断を誤ると、開発後期でのアーキテクチャ変更や機能実装の困難さに直面する可能性があるため、この初期決定は極めて重要です。例えば、当初はシンプルな宣言的モードで開発を開始したものの、途中でSSRや高度なデータローディングの要件が発生した場合、データモードやフレームワークモードへの移行は大きなコストと時間を要する可能性があります。React Router v7 がデータ管理やサーバー連携を含む包括的なアプリケーションフレームワークへと進化している点を踏まえると、特に新規プロジェクトではデータモードまたはフレームワークモードの採用を積極的に検討する価値があります。

**Table 1: React Router v7 モード比較**

| 特徴 | 宣言的モード (Declarative Mode) | データモード (Data Mode) | フレームワークモード (Framework Mode) |
| :---- | :---- | :---- | :---- |
| 主なAPI | \<Routes\>, \<Route\> | createBrowserRouter, ルートオブジェクト | app/routes.ts (route, index 等), ルートモジュール |
| データローディング | 限定的 (外部で実装推奨) | loader プロパティ (ルートオブジェクト内) | loader, clientLoader (ルートモジュール内) |
| データ送信 | 限定的 (外部で実装推奨) | action プロパティ (ルートオブジェクト内) | action, clientAction (ルートモジュール内) |
| エラー処理 | \<ErrorBoundary\> (手動設置) | ルートオブジェクトの errorElement (※1), \<ErrorBoundary\> | ルートモジュールの ErrorBoundary エクスポート |
| コード分割 | 手動設定 (例: React.lazy) | ルートオブジェクトの lazy プロパティ | 自動 (ルートモジュール単位), lazy プロパティ |
| SSR/Prerendering | 限定的 (手動設定が必要) | 設定により可能 | 標準サポート |
| 推奨ユースケース | 小規模SPA、静的サイト、UI中心のルーティング | データ駆動型SPA、クライアントサイドでの複雑なデータ操作 | 大規模SPA、SSR/Prerendering必須、フルスタック風アプリケーション、パフォーマンスと開発効率の両立を求める場合 |

(※1) errorElement のルートオブジェクトでの詳細な使用法は提供された情報源からは明確に記述されていません 3。\<Await\> コンポーネントでは errorElement が使用されます 4。主に ErrorBoundary コンポーネントがエラー処理のメカニズムとして強調されています \[1 (Error Boundary Details)\]。

この比較表は、各モードの主要な特性と能力を概観し、プロジェクトの初期段階におけるモード選択の意思決定を支援することを目的としています。例えば、「サーバーサイドレンダリングが必須要件である」場合、フレームワークモードが最も有力な候補となります。同様に、「データ取得ロジックをルート定義と密接に連携させたい」のであれば、データモードまたはフレームワークモードが適しているでしょう。この初期判断は、後続のコーディング規約の理解と適用、そしてアプリケーション全体のアーキテクチャ設計の基盤となります。

## **1\. ルーティング定義規約 (Routing Definition Conventions)**

ルーティング定義はアプリケーションの骨格を形成する重要な部分です。React Router v7 では選択したモードによって定義方法が異なるため、モードに応じた規約を遵守することが求められます。

### **1.1. モード別ルーティング設定 (Mode-Specific Routing Configuration)**

#### **1.1.1. フレームワークモード (app/routes.ts の規約) (Framework Mode Conventions)**

フレームワークモードでは、ルーティング設定は一元的に管理され、規約に基づいたファイル構成が推奨されます。

* **規約:** すべてのルーティング設定は、プロジェクトのルートディレクトリ直下にある app/routes.ts ファイルに集約して記述します 1。  
* **規約:** app/routes.ts 内で定義される各ルートは、URLパスパターンと、そのルートに対応する挙動を定義したルートモジュールへのファイルパスを必須要素として持ちます 1。  
* **推奨:** ルート定義には、@react-router/dev/routes パッケージから提供される route, index, layout, prefix といったヘルパー関数を積極的に利用します 1。  
  * route(path, modulePath, children?): 指定されたパスとモジュールに対する基本的なルートを定義します。オプションで子ルートの配列を受け取ることができます。  
  * index(modulePath): 親ルートのURLにマッチした際にデフォルトでレンダリングされるインデックスルートを定義します。このルートは自身のパスを持ちません 1。  
  * layout(modulePath, children): URLパスに新たなセグメントを追加することなく、子ルート群のための新しいネストレベル（レイアウト）を作成します。これにより、共通のUI構造を複数の子ルートで共有できます 1。  
  * prefix(pathPrefix, children): 指定されたパスプレフィックスを子ルート群に適用します。これは、共通の親ルートモジュール（レイアウトコンポーネント）なしでURL階層を形成したい場合に便利です 1。  
* **コード例 (基本的なルート定義):**  
  TypeScript  
  // app/routes.ts  
  import { type RouteConfig, route, index, layout } from "@react-router/dev/routes";

  export default \[  
    index("./home.tsx"), // ルートパス ("/") に対応  
    route("about", "./about.tsx"), // "/about" に対応  
    layout("./shared-layout.tsx", \[ // 共通レイアウト  
      route("products", "./products/list.tsx"),  
      route("products/:productId", "./products/detail.tsx"),  
    \]),  
  \] satisfies RouteConfig;

  上記コード例は 1 の情報を基に構成されています。

フレームワークモードにおける app/routes.ts を中心としたルート定義は、アプリケーション全体のURL構造とそれに対応するモジュールを一元的に把握できるという利点があります。layout や prefix といったユーティリティ関数は、この構造を宣言的かつ簡潔に記述するための強力なツールであり、これらを適切に活用することで、URL設計とコンポーネント/モジュール構成が明確に関連付けられ、コードの可読性と保守性が向上します。特に大規模なアプリケーションにおいて、この中央集権的な管理方法は、ルーティングの見通しを良くし、特定のURLに対応するコードを発見しやすくするため、メンテナンス性やチーム開発の効率向上に大きく寄与します。この規約に従うことは、React Router チームが提供する将来的なツールや最適化の恩恵を受けやすくする可能性も秘めています。

#### **1.1.2. データモード (createBrowserRouter の規約) (Data Mode Conventions)**

データモードでは、JavaScriptのオブジェクトと関数を用いて、よりプログラム的なルーティング設定を行います。

* **規約:** ルーティング設定は、createBrowserRouter (または createHashRouter, createMemoryRouter といった環境に応じたルーター作成関数) の第一引数に渡す、ルートオブジェクトの配列として定義します 1。  
* **規約:** 配列内の各ルートオブジェクトは、最低限 path プロパティ (静的または動的なパスセグメント) または index: true (インデックスルートの場合) と、そのルートがマッチした際にレンダリングされる Component プロパティを持つ必要があります 1。  
* **推奨:** ネストされたルート構造を表現するには、親ルートオブジェクトの children プロパティに、子ルートオブジェクトの配列を指定します 1。  
* **推奨:** URLに新たなパスセグメントを追加せずに共通のレイアウトコンポーネントを適用したい場合（レイアウトルート）、親となるルートオブジェクトから path プロパティを省略し、Component プロパティ（レイアウトコンポーネントを指定）と children プロパティ（実際のページコンポーネントを持つ子ルート群を指定）を設定します 1。  
* **コード例 (基本的なルート定義):**  
  JavaScript  
  import { createBrowserRouter, Outlet } from "react-router-dom"; // Outletもインポート  
  import HomePage from "./pages/Home";  
  import AboutPage from "./pages/About";  
  import ProductsLayout from "./layouts/ProductsLayout";  
  import ProductListPage from "./pages/products/List";  
  import ProductDetailPage from "./pages/products/Detail";

  const router \= createBrowserRouter(,  
    },  
  \]);

  上記コード例は 1 の情報を基に構成されています。

データモードのルートオブジェクトはプレーンなJavaScriptオブジェクトであるため、配列操作（map, filter など）や条件分岐を組み合わせることで、実行時に動的にルートを生成したり、特定の条件下でのみルートを定義したりといった柔軟な対応が可能です。この特性は、例えばユーザーの権限レベルに応じて表示するルートを切り替える、CMSから取得したデータに基づいてページルートを動的に構築する、といったシナリオで非常に有効です。loader や action といったデータ操作関数をルートオブジェクトに直接関連付けられるため 1、データ要件とコンポーネントの結びつきが強固になり、関心の分離とロジックの局所化が促進されます。ただし、この柔軟性を過度に追求すると、ルート全体の定義が複雑化し、可読性や管理性が損なわれる可能性もあるため、プロジェクトの特性に応じたバランスの取れた設計が重要となります。

#### **1.1.3. 宣言的モード (\<Routes\>, \<Route\>) の規約と留意点 (Declarative Mode Conventions and Considerations)**

宣言的モードは、Reactコンポーネントツリー内で直接ルーティングを記述する、最も伝統的なスタイルです。

* **規約:** ルーティングは、JSX内で \<Routes\> コンポーネントを配置し、その子要素として一つ以上の \<Route\> コンポーネントをネストすることで宣言的に定義します。  
* **留意点:** 宣言的モードで使用される \<Route\> コンポーネントは、React Router v7 の主要なデータ機能であるデータローディング (loader)、データ送信 (action)、自動コード分割、その他ルートモジュールに関連する機能（フレームワークモードで提供される headers や型生成など）には関与しません 2。これらの機能が必要となる場合は、データモードまたはフレームワークモードの採用を強く推奨します。  
* **情報不足に関する注記:** 宣言的モードのルーティングに関する詳細な情報 (例: \<Route\> の全プロパティや高度な使用法) は、参照した資料からは限定的でした \[1 (Declarative Mode Routing Details), 15 は情報取得不可\]。  
* **利用シーン:** 主に、アプリケーション全体ではなく、特定のUIコンポーネント群の中で局所的なルーティング分岐（例: タブ切り替え、ウィザード形式のステップ表示など）を行いたい場合や、データフェッチを伴わない非常にシンプルなSPAに適しています。フレームワークモードのドキュメント内で「コンポーネントルート」として言及されている例 1 は、このような限定的なユースケースに該当しますが、データ機能は利用できないと明記されています 1。  
* **コード例 (基本的なルート定義):**  
  JavaScript  
  import { Routes, Route } from "react-router-dom";  
  import HomePage from "./pages/Home";  
  import AboutPage from "./pages/About";  
  import NotFoundPage from "./pages/NotFound";

  function AppRoutes() {  
    return (  
      \<Routes\>  
        \<Route path\="/" element\={\<HomePage /\>} /\>  
        \<Route path\="about" element\={\<AboutPage /\>} /\>  
        {/\* 他の具体的なルートにマッチしなかった場合に表示するルート \*/}  
        \<Route path\="\*" element\={\<NotFoundPage /\>} /\>  
      \</Routes\>  
    );  
  }

  上記コード例は 1 のコンポーネントルートの例を参考に、宣言的モードの基本的な形式として提示しています。

宣言的モードはReactのコンポーネントモデルに最も忠実なルーティング表現方法と言えますが、React Router v7 が目指す方向性であるデータ管理機能との緊密な統合という観点からは、やや限定的な位置づけとなっています。データローディングやアクションといった機能が \<Route\> コンポーネントに直接組み込まれていないため 2、これらの機能を実現するには、Context API と useEffect フックを組み合わせたデータフェッチ処理や、外部の状態管理ライブラリ（Redux, Zustandなど）との連携といった追加の実装が必要となり、結果としてコードが煩雑になる可能性があります。アプリケーションの成長に伴いデータ要件が複雑化した場合、宣言的モードからデータモードやフレームワークモードへの移行を迫られることも考えられます。このような移行は相応のコストを伴うため、プロジェクト開始時の慎重なモード選択が、将来的な技術的負債を回避する上で重要です。

### **1.2. ルートオブジェクトプロパティの規約 (path, Component/element, children, index, lazy 等) (Route Object Property Conventions)**

データモードやフレームワークモードでルートを定義する際、ルートオブジェクト（または route 関数の引数）には様々なプロパティを指定できます。これらのプロパティを規約に沿って使用することで、ルーティング定義の明確性と一貫性が向上します。

* **path (文字列):**  
  * **規約:** URLパスパターンを文字列で定義します。このパスパターンには、静的なセグメント (/about)、動的なセグメント (/:userId)、オプショナルセグメント (/:lang?)、そしてスプラットセグメント (/\*) を含めることができます 1。  
  * **推奨:** パス名は、そのルートが示すリソースや機能を具体的に表す、意味のある単語（通常は英語）で構成し、単語間はハイフンでつなぐケバブケース (例: user-profile, product-details) を使用します。これによりURLの可読性が向上します。  
* **Component (Reactコンポーネント):**  
  * **規約:** ルートがURLにマッチした際にレンダリングされるReactコンポーネントを指定します 3。  
  * **推奨:** element プロパティ（JSX要素を渡す形式、例: element={\<MyComponent /\>}）よりも、コンポーネントの参照を直接渡す Component プロパティ (例: Component: MyComponent) の使用を推奨します。提供された資料 3 では Component プロパティのみが言及されており、element プロパティとの明確な使い分けや element プロパティ自体の詳細な情報は不足しています。React Router の進化の過程や、loader/action からデータを受け取る設計との親和性を考慮すると、Component プロパティが主流となっていると考えられます。element={\<MyComponent /\>} のようにJSX要素を渡す形式は、ルートがマッチするたびにコンポーネントの新しいインスタンスが生成される可能性があり、パフォーマンスや内部状態の保持において不利になることがあります。Component プロパティの方が、React Router による最適化の恩恵を受けやすい設計である可能性が高いです。この規約で Component を推奨することにより、チーム内での混乱を避け、より一貫性のある効率的なコードベースの構築を目指します。  
* **children (ルートオブジェクトの配列):**  
  * **規約:** ネストされたルート（子ルート）を定義するために使用します。親ルートのコンポーネント内では、\<Outlet /\> コンポーネントを配置することで、マッチした子ルートがレンダリングされる場所を指定します 1。  
* **index (真偽値):**  
  * **規約:** true に設定されたルートはインデックスルートとなり、親ルートのパスに完全にマッチした際にデフォルトでレンダリングされます 1。例えば、親ルートのパスが /dashboard で、子に index: true を持つルートがある場合、URL /dashboard へのアクセスでその子ルートがレンダリングされます。  
  * **規約:** インデックスルートは、自身の path プロパティを持つことはできません。また、さらに子ルート (children) を持つこともできません 1。  
* **lazy (非同期関数):**  
  * **規約:** ルートの Component や、関連する loader 関数、action 関数などを動的にインポート (遅延読み込み) するために使用します。これにより、初期バンドルサイズを効果的に削減し、コード分割を実現できます 3。  
  * **推奨:** アプリケーションのパフォーマンス向上のため、特に初期表示に必須ではない大規模な機能ルートや、利用頻度の低い管理画面のルートなどに対して、積極的に lazy プロパティの利用を検討します。  
  * **コード例 (データモードでの lazy 利用):**  
    JavaScript  
    // データモードの createBrowserRouter に渡すルートオブジェクトの例  
    import { createBrowserRouter } from "react-router-dom";

    const router \= createBrowserRouter(\[  
      {  
        path: "/heavy-feature",  
        async lazy() {  
          // コンポーネントとローダーを並行して動的インポート  
          let { HeavyFeatureComponent } \= await import("./features/HeavyFeatureComponent");  
          let { heavyFeatureLoader } \= await import("./features/heavyFeatureLoader");  
          return { Component: HeavyFeatureComponent, loader: heavyFeatureLoader };  
        },  
      },  
      // 他のルート定義...  
    \]);  
    上記コードは 3 及び 3 の情報を参考に構成されています。  
  * **注意点:** lazy プロパティを使用してモジュールを遅延読み込みする場合、読み込みが完了するまでの間にユーザーに何らかのフィードバック（ローディングスピナーやスケルトンスクリーンなど）を表示することが推奨されます。これは、React の \<Suspense\> コンポーネントをルート階層の適切な場所に配置し、fallback プロパティにフォールバックUIを指定することで実現できます 3。  
* **loader (非同期関数):**  
  * **規約:** ルートコンポーネントがレンダリングされる前に、そのルートに必要なデータを非同期に取得するために使用します。詳細は本規約の「3.1. データローディング」セクションで詳述します。  
* **action (非同期関数):**  
  * **規約:** フォーム送信などによってトリガーされるデータ変更処理（作成、更新、削除など）を定義します。詳細は本規約の「3.2. データ送信・アクション」セクションで詳述します。  
* **errorElement (React要素) / ErrorBoundary (Reactコンポーネント \- フレームワークモード):**  
  * **規約 (データモード \- 推測を含む):** データモードのルートオブジェクトにおいて errorElement プロパティにReact要素を指定することで、そのルートでエラー（loader や action でのスロー、またはレンダリング中のエラー）が発生した際に表示されるフォールバックUIを定義します。この errorElement 内では useRouteError フックを使用してエラーオブジェクトにアクセスできます。  
    * **情報不足に関する警告:** 提供された資料からは、データモードのルートオブジェクトにおける errorElement プロパティの具体的な使用法や、useRouteError フックとの連携に関する詳細な説明が不足しています 3。4 は \<Await\> コンポーネントの errorElement について言及しており、ルート定義の errorElement とは異なる可能性があります。また、6 (useRouteError)7 (error-element) も情報が得られませんでした。  
  * **規約 (フレームワークモード):** フレームワークモードでは、ルートモジュール（例: some-route.tsx）から ErrorBoundary という名前でReactコンポーネントをエクスポートすることで、そのルートおよびその子ルートで発生したエラーを捕捉し、カスタムエラーUIを表示します \[1 (Error Boundary Details), 11\]。この ErrorBoundary コンポーネント内でも useRouteError フックを利用してエラー情報にアクセスします。  
  * **推奨:** アプリケーションの最上位のルート（通常は app/root.tsx のようなルートレイアウトコンポーネントに対応するルート）には、必ず包括的な ErrorBoundary (フレームワークモードの場合) またはエラー処理コンポーネント (データモードで errorElement が期待通り機能すると仮定した場合) を設定し、予期せぬエラーによってユーザーに空白のページが表示される事態を防ぎます \[1 (Error Boundary Details {S149})\]。  
  * フレームワークモードでは ErrorBoundary のエクスポートが標準的なエラー処理メカニズムとして明確に示されているのに対し、データモードにおける errorElement の役割やベストプラクティスは提供情報からは曖昧です。この差異は、フレームワークモードがより規約ベースであるのに対し、データモードがより柔軟性を持つ（あるいはドキュメントがその部分について不完全である）可能性を示唆しています。データモードで errorElement を使用する際は、公式ドキュメントの該当箇所をより詳細に確認するか、実験的な検証を行うことが推奨されます。

### **1.3. 動的セグメント・オプショナルセグメント・スプラットセグメントの利用規約 (Conventions for Dynamic, Optional, and Splat Segments)**

URLパスパターン内で特別な意味を持つセグメントを利用することで、より柔軟で表現力豊かなルーティングを実現できます。

* **動的セグメント (Dynamic Segments) (例: :userId):**  
  * **規約:** URLパスの一部を可変の値として扱いたい場合に使用します。動的セグメントは、パス文字列内でコロン : を接頭辞として記述します (例: /users/:userId, /products/:productId/reviews/:reviewId) 1。  
  * **推奨:** 動的セグメント名は、そのセグメントがキャプチャする値が何を表すかを明確に示す単数形の名詞（例: :teamId, :documentSlug）とし、キャメルケースまたはスネークケースよりもケバブケース（例: :product-id）または単一単語を推奨します。  
  * **値へのアクセス:** 動的セグメントでキャプチャされた実際のURLの値は、対応するルートの loader 関数や action 関数の引数として渡される params オブジェクトを通じて、またはルートコンポーネント内で useParams() フックを利用して取得できます 1。  
* **オプショナルセグメント (Optional Segments) (例: :lang?):**  
  * **規約:** URLパス内の特定のセグメントを任意（存在してもしなくてもよい）としたい場合、そのセグメントの末尾にクエスチョンマーク ? を付加します 1。これは動的セグメント (:param?) だけでなく、静的なセグメント (/edit?) に対しても適用可能です 1。  
  * **利用シーン:** 国際化対応でURLに言語コードを含めるが、デフォルト言語の場合は言語コードを省略したい場合 (例: /en/about と /about の両方を同じルートにマッチさせる)、あるいは特定の機能フラグをURLで表現する場合などが考えられます。  
  * **コード例 (フレームワークモード):** route(":lang?/categories", "./categories.tsx") は、/en/categories と /categories の両方にマッチし、:lang パラメータは前者では "en"、後者では undefined となります 1。  
* **スプラットセグメント (Splat Segments / Catch-all / Star Segments) (例: files/\*):**  
  * **規約:** ルートパスパターンの末尾に /\* を使用すると、そのプレフィックス以降の任意の文字列（スラッシュ / を含むネストされたパスも含む）にマッチします 1。これは「キャッチオール」や「ワイルドカード」とも呼ばれます。  
  * **値へのアクセス:** スプラットセグメントによってマッチしたURLの末尾部分は、params オブジェクト内でキー "\*" (アスタリスク) の値として取得できます。分割代入を用いて splat のようなより分かりやすい変数名に割り当てることも一般的です 1。  
  * **利用シーン:** ファイルブラウザのように未知の深さのパス構造を扱う場合や、アプリケーション内の他のどのルートにもマッチしなかったURLを捕捉してカスタム404ページを表示する場合などに利用できます。ただし、一般的な404エラー処理は、エラー境界メカニズム (セクション4参照) を使用する方がより適切である場合が多いです。  
  * **注意:** スプラットセグメントは非常に広範囲にマッチするため、「最も貪欲な」ルートとなります。意図しないルートがスプラットセグメントに捕捉されるのを避けるため、ルート定義の配列内では、より具体的なパスパターンを持つルートの後に配置することを強く推奨します。

これらのセグメントタイプを効果的に組み合わせることで、アプリケーションの要件に応じた柔軟なURLスキーマを設計できます。しかし、過度な複雑性はURLの予測可能性を低下させ、デバッグを困難にする可能性があるため、設計の際には明快さと保守性を常に念頭に置く必要があります。動的セグメントはデータ取得のキーとして自然に機能し (loader の params を介して)、RESTfulなAPI設計との親和性も高いです。オプショナルセグメントはURLのバリエーションを許容し、スプラットセグメントは「その他すべて」を捉える強力なツールですが、その強力さゆえに慎重な使用が求められます。明確で一貫性のあるセグメント利用規約をチーム内で共有することは、ユーザビリティ、SEO、そして内部的な状態管理といった多岐にわたる側面に好影響を与えます。

### **1.4. ファイルシステムベースルーティングの指針 (Framework Mode) (Guidelines for File-System Based Routing)**

フレームワークモードでは、従来の明示的なルート設定ファイル (app/routes.ts) に加えて、またはその代替として、ファイルシステムのディレクトリ構造とファイル名に基づいた規約ベースのルーティングを利用するオプションが提供されます。

* **規約:** フレームワークモードにおいて、ルート定義を app/routes ディレクトリ（または設定された他のディレクトリ）内のファイルやフォルダの命名規則に基づいて自動的に生成させることができます。これは、Next.js や Remix (v1) などのフレームワークで採用されているアプローチと類似しています 1。  
* **利用方法:** この機能を利用するには、通常 @react-router/fs-routes のような関連パッケージ（具体的なパッケージ名はバージョンや設定により異なる可能性があります）が提供するユーティリティ関数（例: flatRoutes()）を使用します。この関数を app/routes.ts 内で呼び出し、その結果を既存の明示的なルート定義とマージすることで、ファイルシステムベースのルートをアプリケーションに統合します 1。  
* **推奨事項:** プロジェクトの規模、チームの好み、そしてURL構造の複雑さを考慮して、完全にファイルシステムベースのルーティングを採用するか、app/routes.ts での明示的な設定と組み合わせるハイブリッドアプローチを取るか、あるいは完全に明示的な設定のみに依存するかを決定します。  
* **コード例 (app/routes.ts でファイルシステムルートを統合):**  
  TypeScript  
  // app/routes.ts  
  import { type RouteConfig, route } from "@react-router/dev/routes";  
  // @react-router/fs-routes から適切なユーティリティをインポートすると仮定  
  import { flatRoutes } from "@react-router/fs-routes"; // このインポートパスは仮のものです

  export default async function routes() { // flatRoutes が Promise を返す場合、関数を async にする  
    const fsRoutes \= await flatRoutes(); // ファイルシステムからルートを読み込む

    return satisfies RouteConfig;  
  }  
  上記コード例は 1 の概念を基に、より実践的な統合方法を示しています。flatRoutes() の具体的な挙動や返り値の型は、使用するパッケージのドキュメントを参照してください。  
* **参照:** ファイルシステムベースルーティングの具体的なファイル命名規則や利用可能なオプションについては、React Router の公式ドキュメント内にある「[ファイルルートの規約](https://react-router-docs-ja.techtalk.jp/how-to/file-route-conventions)」のセクションを必ず参照してください 1。

ファイルシステムベースルーティングは、特に規約に慣れたチームや、ディレクトリ構造がそのままURL構造に反映されることが自然なプロジェクト（例: ドキュメンテーションサイト、ブログなど）において、新しいルートの追加を「単にファイルやフォルダを作成するだけ」という直感的な作業に単純化し、開発速度を向上させる可能性があります。一方で、非常に複雑なURL構造や、ファイルシステムの階層とは異なる論理的なルーティング階層が求められる場合には、ファイルシステムベースの規約だけでは表現しきれないか、ディレクトリ構造が不自然に深くなったり、管理が煩雑になったりする可能性があります。app/routes.ts での明示的な設定と組み合わせることで、ファイルシステムルーティングの利便性を享受しつつ、複雑なケースには手動設定で柔軟に対応するというバランスの取れたアプローチが可能です。

## **2\. ナビゲーション規約 (Navigation Conventions)**

アプリケーション内でのページ遷移（ナビゲーション）はユーザーエクスペリエンスの中核をなす要素です。React Router v7 は、このナビゲーションを実現するための複数の手段を提供しており、それぞれの特性を理解し、状況に応じて適切に使い分けることが重要です。

### **2.1. ナビゲーションコンポーネントの選定 (\<Link\>, \<NavLink\>) (Selecting Navigation Components)**

ユーザーがクリックすることでページ遷移を引き起こす基本的なUI要素として、\<Link\> と \<NavLink\> の2つの主要なコンポーネントが提供されています。

* **\<Link\> コンポーネント:**  
  * **規約:** 最も基本的なページ遷移に使用します。このコンポーネントは、指定された to プロパティのパスへユーザーをナビゲートするアンカー (\<a\>) タグをレンダリングします。アクティブ状態（現在のURLとリンク先のパスが一致している状態）を示す特別なスタイリング機能は持ちません 1。  
  * **推奨:** ナビゲーションメニューやタブのように、ユーザーが現在どのページにいるかを示す視覚的なフィードバックが不要な場合に限定して使用します。例えば、文章中の参照リンクや、単に別のページへ移動させるためのボタン風の要素などに適しています。  
  * **コード例:**  
    JavaScript  
    import { Link } from "react-router-dom";

    function Footer() {  
      return (  
        \<footer\>  
          \<p\>詳細は \<Link to\="/about-us"\>会社概要\</Link\> をご覧ください。\</p\>  
          \<p\>\<Link to\="/terms-of-service"\>利用規約\</Link\>\</p\>  
        \</footer\>  
      );  
    }

* **\<NavLink\> コンポーネント:**  
  * **規約:** ナビゲーションメニュー、タブバー、パンくずリストなど、リンク先のパスが現在のURLと一致する場合（アクティブ状態）や、遷移中である場合（ペンディング状態）に、特別なスタイルやコンテンツを適用したい場合に使用します 1。  
  * **推奨:** className、style、または children プロパティに関数を渡すことで、リンクの状態 (isActive, isPending, isTransitioning といったプロパティを持つオブジェクトが関数に渡されます) に基づいて動的なスタイリングやコンテンツの変更を行います 1。これにより、CSSクラスの付け替え、インラインスタイルの変更、アイコンの追加などを状態に応じて柔軟に制御できます。  
    * isActive: リンクが現在のURLと完全に（または end プロパティの設定に応じて部分的に）一致している場合に true となります。  
    * isPending: リンク先へのナビゲーションが開始されたが、まだ完了していない（例: loader が実行中）場合に true となります。  
    * isTransitioning (フレームワークモード): ビュートランジションが実行中の場合に true となります。  
  * **end プロパティ:**  
    * **規約:** NavLink がアクティブと判定される条件を、より厳密に「完全一致」に限定したい場合（例えば、/ というリンクが /items のような子パスでもアクティブになってしまうのを防ぎたい場合）に、end プロパティを true に設定します 1。これは、親ルートにネストされたインデックスルートへのリンクや、パス階層のルートへのリンクで特に有用です。  
  * **コード例 (className プロパティに関数を指定):**  
    JavaScript  
    import { NavLink } from "react-router-dom";

    function MainNavigation() {  
      const getLinkClassName \= ({ isActive, isPending }) \=\> {  
        let classes \= "nav-link";  
        if (isActive) classes \+= " active-nav-link";  
        if (isPending) classes \+= " pending-nav-link";  
        return classes;  
      };

      return (  
        \<nav\>  
          \<NavLink to\="/" end className\={getLinkClassName}\>ホーム\</NavLink\>  
          \<NavLink to\="/products" className\={getLinkClassName}\>製品一覧\</NavLink\>  
          \<NavLink to\="/contact" className\={getLinkClassName}\>お問い合わせ\</NavLink\>  
        \</nav\>  
      );  
    }  
    上記コード例は 1 の情報を参考に、より一般的なクラス名付与のパターンとして構成しています。

\<Link\> と \<NavLink\> は、どちらも最終的にセマンティックな \<a\> タグをレンダリングするため、キーボード操作によるフォーカス移動やEnterキーでの遷移、スクリーンリーダーによる適切な読み上げ、右クリックメニューからの「新しいタブで開く」といったブラウザ標準のアクセシビリティ機能やユーザーエクスペリエンスの恩恵をデフォルトで受けることができます。安易に useNavigate フック（後述）をボタンの onClick イベント等で使用すると、これらの \<a\> タグ固有の利点が失われる可能性があるため、ユーザーが「リンク」として期待するUI要素には、原則として \<Link\> または \<NavLink\> を使用することが強く推奨されます。

**Table 2: ナビゲーション手段の比較と推奨ユースケース**

| 手段 | 主な目的 | アクティブ状態判定 | データ送信 | プログラムからの制御 | 履歴への影響 | 推奨ユースケース |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- |
| \<Link\> | 基本的なページ遷移 | なし | 不可 | 不可 | 新規履歴エントリ追加 | 一般的なテキストリンク、画像リンクなど、アクティブ表示が不要な場合 |
| \<NavLink\> | アクティブ状態を持つナビゲーションリンク | あり | 不可 | 不可 | 新規履歴エントリ追加 | ナビゲーションバー、サイドバーメニュー、タブインターフェースなど、ユーザーに現在位置を視覚的にフィードバックする必要がある場合 |
| useNavigate | プログラムによるページ遷移 | なし (※2) | 不可 | 可能 | 柔軟 (replaceオプション等) | フォーム送信完了後、認証状態の変化時 (ログイン/ログアウト)、タイマーやWebSocketイベントに応じた自動遷移など、ユーザーの直接的なクリック操作以外での遷移 |
| \<Form method="get"\> | URLパラメータを通じたナビゲーション/状態表現 | なし | GETメソッド | 不可 | 新規履歴エントリ追加 | 検索フォーム、フィルタリングオプション、ソート順指定など、状態をURLに反映させて共有可能にしたい場合 |
| \<Form method="post"\> | データ送信 (アクション呼び出し) を伴うナビゲーション | なし | POSTメソッド | 不可 | 新規履歴エントリ追加 | データ作成・更新フォーム (ただし、ページ遷移を伴わない場合は fetcher の方が適していることが多い 1) |
| redirect (ユーティリティ) | loader / action 内からのサーバーサイド主導リダイレクト | なし (※2) | \- | サーバーサイドで可能 | \- | 認証失敗時のログインページへの強制転送、データ作成/更新後の詳細ページへのリダイレクトなど、サーバー処理の結果に基づく遷移 8 |

(※2) useNavigate や redirect 自体はアクティブ状態を持ちませんが、遷移先のルートが \<NavLink\> によってアクティブと判定されることはあります。

この表は、React Router v7 が提供する多様なナビゲーション手段の特性を整理し、開発者が特定の要件や状況に応じて最適なものを迅速に選択できるよう支援することを目的としています。例えば、「ユーザーがクリックするナビゲーションバーの項目で、現在表示中のページに対応する項目をハイライトしたい」という要件であれば、\<NavLink\> が最適です。一方、「フォーム送信が成功したら、ユーザーをダッシュボードページに自動的に遷移させたい」という場合は、action からの redirect または useNavigate が候補となります。適切なAPIを選択することで、手戻りを減らし、より効率的でユーザーフレンドリーなナビゲーションフローを構築できます。

### **2.2. プログラムによるナビゲーション (useNavigate) の利用指針 (Guidelines for Programmatic Navigation)**

useNavigate フックは、コンポーネントのロジック内から命令的にページ遷移を実行するための手段を提供します。

* **規約:** useNavigate フックは、ユーザーの直接的なインタラクション（リンクのクリックなど）に基づかないページ遷移が必要な場合に限定して使用します 1。\<Link\> や \<NavLink\> が提供するアクセシビリティやユーザーエクスペリエンス上の利点を考慮し、可能な限りこれらのコンポーネントによるナビゲーションを優先します。  
* **推奨されるユースケース:**  
  * フォームの送信処理が非同期で完了した後、成功ページや一覧ページへリダイレクトする場合（ただし、データモードやフレームワークモードでは、ルートの action 関数から redirect レスポンスを返す方が、データの再検証なども含めてより統合的なアプローチとなることが多いです）。  
  * ユーザーの認証状態が変化した際（例: ログイン成功後にダッシュボードへ、セッションタイムアウトで自動的にログアウトページへ）の遷移。  
  * タイマーイベント（例: クイズの制限時間終了）や、サーバーからのWebSocketメッセージ受信など、非同期的な外部イベントに応じてページを切り替える必要がある場合。  
  * 宣言的モードにおいて、フォーム送信などのイベントハンドラ内でページ遷移を行いたい場合 1。  
* **非推奨または注意が必要なユースケース:**  
  * 通常のリンク（\<a\> タグに相当する機能）やナビゲーションメニューの項目を、単に onClick イベントハンドラ内で useNavigate を呼び出すボタンなどで代替すること。これは、前述の通り、キーボード操作性、右クリックメニュー、「新しいタブで開く」機能、SEOへの影響といった点で劣る可能性があります。  
* **navigate 関数のオプション:**  
  * replace: true: 現在のURLをブラウザの履歴スタック内で置き換える形で遷移します（ユーザーが「戻る」ボタンを押しても、遷移元のページには戻りません）。ログインフォームからダッシュボードへの遷移など、戻る必要がない場合に有用です。  
  * state: any: 遷移先のロケーションオブジェクトに任意のデータを関連付けることができます。遷移先のコンポーネントでは useLocation().state でこのデータにアクセスできます。  
* **コード例 (フォーム送信成功後の遷移):**  
  JavaScript  
  import { useNavigate } from "react-router-dom";  
  import { useState } from "react";

  function ContactForm() {  
    const navigate \= useNavigate();  
    const \= useState(false);  
    const \[error, setError\] \= useState(null);

    async function handleSubmit(event) {  
      event.preventDefault();  
      setIsSubmitting(true);  
      setError(null);  
      const formData \= new FormData(event.currentTarget);  
      try {  
        // const response \= await fetch("/api/contact", { method: "POST", body: formData });  
        // if (\!response.ok) throw new Error("送信に失敗しました。");  
        // シミュレーション  
        await new Promise(resolve \=\> setTimeout(resolve, 1000));  
        console.log("Form submitted successfully");

        // 送信成功後、サンクスページに遷移（履歴を置き換える）  
        navigate("/contact/thank-you", { replace: true, state: { message: "お問い合わせありがとうございます！" } });  
      } catch (err) {  
        setError(err.message);  
      } finally {  
        setIsSubmitting(false);  
      }  
    }

    return (  
      \<form onSubmit\={handleSubmit}\>  
        {/\* フォームフィールド... \*/}  
        \<button type\="submit" disabled\={isSubmitting}\>  
          {isSubmitting? "送信中..." : "送信"}  
        \</button\>  
        {error && \<p style\={{ color: "red" }}\>{error}\</p\>}  
      \</form\>  
    );  
  }  
  上記コードは 1 や 1 の useNavigate の使用例を参考に、より一般的なフォーム処理のコンテキストで具体化しています。

### **2.3. \<Form\> を利用したナビゲーションとデータ送信 (Navigation and Data Submission with \<Form\>)**

React Router v7 の \<Form\> コンポーネントは、HTML標準のフォームの振る舞いを模倣しつつ、クライアントサイドルーティングとシームレスに統合された形でナビゲーションやデータ送信（アクションの呼び出し）を実現します。

* **method="get" での利用 (URLパラメータによるナビゲーション):**  
  * **規約:** \<Form method="get" action="/some-path"\> のように指定すると、フォーム送信時に action で指定されたパスへナビゲートします。その際、フォームの入力フィールドの値はURLの検索パラメータ (クエリ文字列) としてエンコードされ、URLに追加されます 1。  
  * **利用シーン:** 検索フォーム（検索語をURLに含める）、フィルタリング機能（選択されたフィルタ条件をURLに反映させる）、ソート順の指定など、アプリケーションの状態をURLで表現し、ユーザーがそのURLをブックマークしたり共有したりできるようにしたい場合に適しています。遷移先のルートの loader 関数は、これらのURL検索パラメータにアクセスしてデータを取得できます。  
  * **コード例 (検索フォーム):**  
    JavaScript  
    import { Form } from "react-router-dom";

    function SearchHeader() {  
      return (  
        \<Form action\="/search-results" method\="get"\>  
          \<input type\="text" name\="query" placeholder\="キーワードを入力..." /\>  
          \<select name\="category"\>  
            \<option value\=""\>すべて\</option\>  
            \<option value\="books"\>書籍\</option\>  
            \<option value\="electronics"\>家電\</option\>  
          \</select\>  
          \<button type\="submit"\>検索\</button\>  
        \</Form\>  
      );  
    }  
    // ユーザーが "React" と入力し "書籍" を選択して送信すると、  
    // /search-results?query=React\&category=books へナビゲートする。  
    上記コードは 1 の概念を基に構成されています。  
* **method="post" (または put, patch, delete) での利用 (データ送信とアクション呼び出し):**  
  * **規約:** \<Form method="post" action="/submit-data"\> のように指定すると、フォームデータは FormData オブジェクトとしてエンコードされ、action で指定されたパス（またはフォームがレンダリングされている現在のルート）に対応するルートの action 関数へ送信されます。このプロセスは通常、ページ全体のナビゲーションを伴います 1。  
  * **注意:** データ送信が主目的であり、ページ全体のナビゲーションやURLの変更を伴う必要がない場合（例: 「いいね！」ボタンのクリック、タスクの完了状態の切り替えなど、UIの一部分のみを更新する操作）は、後述する useFetcher() や fetcher.Form の利用がより適切です 1。  
  * **コード例 (新規プロジェクト作成フォーム):**  
    JavaScript  
    import { Form } from "react-router-dom";

    function NewProjectForm() {  
      return (  
        // action を省略すると、フォームがレンダリングされている現在のルートの action が呼ばれる  
        \<Form method\="post"\>  
          \<div\>  
            \<label htmlFor\="projectName"\>プロジェクト名:\</label\>  
            \<input type\="text" id\="projectName" name\="projectName" required /\>  
          \</div\>  
          \<div\>  
            \<label htmlFor\="description"\>説明:\</label\>  
            \<textarea id\="description" name\="description" /\>  
          \</div\>  
          \<button type\="submit"\>作成\</button\>  
        \</Form\>  
      );  
    }

\<Form\> コンポーネントは、プログレッシブエンハンスメントの原則にも沿っており、JavaScriptが無効な環境でもある程度機能する可能性があります（その場合は通常のHTMLフォームとしてサーバーに送信されます）。React Router は、この \<Form\> の送信をインターセプトし、クライアントサイドでスムーズな遷移とデータ処理を実現します。

### **2.4. redirect ユーティリティの利用規約 (Conventions for Using the redirect Utility)**

redirect ユーティリティは、主に loader 関数や action 関数の内部で、プログラムによってユーザーを別のURLへリダイレクトさせるためのレスポンスオブジェクトを生成する際に使用します。

* **規約:** loader 関数または action 関数内で、特定の条件に基づいて現在の処理を中断し、クライアント（ブラウザ）を別のURLへ遷移させる必要がある場合に、redirect(targetUrl, options?) を呼び出し、その返り値である Response オブジェクトを関数の結果として返します 1。  
* **推奨:** redirect ユーティリティは、サーバーサイド（または loader/action が実行されるそれに準じるコンテキスト）でのリダイレクト指示に使用します。クライアントサイドのコンポーネントロジック内でのリダイレクトには、前述の useNavigate フックや、宣言的なリダイレクトを行うための \<Navigate\> コンポーネント（本規約では詳細を割愛）を使用します。  
* **HTTPステータスコード:** redirect はデフォルトでHTTPステータスコード 302 Found (一時的なリダイレクト) を持つレスポンスを生成します。必要に応じて、第二引数の init オブジェクトで status プロパティを指定することにより、異なるステータスコード（例: 301 Moved Permanently 恒久的な移動）を設定できます 9。  
  * 例: return redirect("/new-location", { status: 301 });  
* **コード例 (loader 内での認証チェックとリダイレクト):**  
  TypeScript  
  // フレームワークモードのルートモジュールやデータモードのルートオブジェクトの loader 内  
  import { redirect } from "react-router-dom"; // または "react-router"  
  // import { getCurrentUser } from "./auth-utils"; // ユーザーセッション/認証情報を取得するユーティリティ関数（仮定）

  export async function loader({ request }) {  
    // const user \= await getCurrentUser(request); // request オブジェクトからクッキーやヘッダーを読み取り認証状態を確認  
    const isAuthenticated \= false; // 仮の認証状態

    if (\!isAuthenticated) {  
      const currentPath \= new URL(request.url).pathname;  
      const loginUrl \= new URL("/login", request.url);  
      // リダイレクト後に元のページに戻れるように、リダイレクト元URLをクエリパラメータとして渡す  
      loginUrl.searchParams.set("redirectTo", currentPath);

      // redirect を throw すると、loader の返り値の型推論がうまくいくことがある (Remix での一般的なパターン)  
      // return redirect(loginUrl.toString()); でも可  
      throw redirect(loginUrl.toString());   
    }

    // 認証済みの場合、通常のデータを返す  
    return { message: "ようこそ、保護されたページへ！" };  
  }  
  上記コードは 8 及び 1 の例を参考に、認証の文脈でより具体的に記述しています。throw redirect(...) は、特にTypeScript環境下で loader の返り値の型を Promise\<Data | Response\> のように扱う際に、型推論を助けるテクニックとして用いられることがあります。

redirect ユーティリティは、HTTPレスポンスを直接操作する比較的低レベルな機能です。loader や action がサーバーサイドで実行される（またはサーバーと同様のコンテキストで動作する）ことを前提としており、これらの関数から Response オブジェクト（redirect が生成するものも含む）を返すことで、React Router は通常のレンダリングフローを中断し、ブラウザに対してリダイレクトを指示します。この仕組みにより、データ取得前（loader）やデータ変更処理後（action）にサーバーサイド主導でアクセス制御（例: 認証チェックと未認証ユーザーのログインページへの強制遷移）を行い、不適切なアクセスを効果的かつセキュアに防ぐことができます。これは、クライアントサイドのみで行うリダイレクト処理と比較して、保護されたリソースへのアクセスをより確実に制御できる利点があります。

## **3\. データフェッチングとミューテーション規約 (Data Fetching and Mutation Conventions)**

React Router v7 のデータモードおよびフレームワークモードは、ルート定義と密接に連携したデータ取得 (フェッチング) とデータ変更 (ミューテーション) のための洗練された仕組みを提供します。これにより、コンポーネントはUIのレンダリングに集中でき、データ関連のロジックはルートレベルで管理されるようになります。

### **3.1. データローディング (loader, clientLoader, useLoaderData) (Data Loading)**

ルートコンポーネントが必要とするデータを、レンダリング前に準備するための機能です。

* **loader (サーバーサイド/共通データローディング):**  
  * **規約 (フレームワークモード):** 各ルートモジュールファイル（例: app/routes/products.tsx）から loader という名前の非同期関数をエクスポートします。この関数は、サーバーサイドでの初期ページロード時や、クライアントサイドでの後続ナビゲーション時（この場合はブラウザからサーバーへ fetch リクエストが発行され、サーバー上の対応する loader が実行される）に呼び出されます 1。  
  * **規約 (データモード):** createBrowserRouter に渡すルートオブジェクトの loader プロパティに非同期関数を指定します 1。この関数は、対応するルートがアクティブになる前に実行されます。  
  * **推奨:** loader 関数内では、データベースへの問い合わせ、外部APIへのリクエスト、ファイル読み込みといった非同期処理を実行し、その結果として得られたデータを返します。この返されたデータは、対応するルートコンポーネントに loaderData という名前のプロパティ (フレームワークモードの場合 10) または useLoaderData() フックを通じて渡されます。Promise、Map、Set、Dateオブジェクトなども返すことができます 1。  
  * **利点 (特にフレームワークモード):** フレームワークモードの loader 関数は、ビルドプロセスによってクライアントサイドのJavaScriptバンドルから削除されます。これにより、データベースの認証情報やサーバー専用のAPIキーといった機密情報を含むコードを loader 内で安全に使用できます 1。  
* **clientLoader (クライアントサイド専用データローディング \- フレームワークモード限定):**  
  * **規約:** フレームワークモードにおいて、データ取得をクライアントサイドでのみ実行したい場合に、ルートモジュールから clientLoader という名前の非同期関数をエクスポートします 1。これは、例えばユーザーのブラウザ環境に依存するデータ（例: localStorage の値、ブラウザAPIの結果）を取得する場合や、SSRの対象外としたい動的なコンテンツの取得に適しています。  
  * **推奨 (HydrateFallback):** clientLoader が実行されている間（特に初期ハイドレーション時やクライアントサイドナビゲーション時）に表示するローディングUIとして、同じルートモジュールから HydrateFallback という名前のReactコンポーネントをエクスポートします 1。  
  * **serverLoader 引数とデータマージ:** clientLoader 関数の第一引数には、同じルートに定義されたサーバー loader の結果を非同期に取得するための serverLoader 関数が渡されます。これにより、サーバーで取得したデータとクライアントで取得したデータをマージしてコンポーネントに渡す、といった高度なデータ戦略を実装できます 1。  
    TypeScript  
    // フレームワークモードのルートモジュール内  
    export async function loader({ params }) { /\* サーバーデータ取得 \*/ return { serverInfo: "..." }; }  
    export async function clientLoader({ request, params, serverLoader }) {  
      const serverData \= await serverLoader(); // サーバーローダーの結果を取得  
      const clientInfo \= await fetch(\`/api/client-specific-data?id=${params.id}\`).then(res \=\> res.json());  
      return {...serverData,...clientInfo }; // マージして返す  
    }

  * **初期ハイドレーション時の実行 (clientLoader.hydrate \= true):** デフォルトでは、clientLoader はクライアントサイドナビゲーション時にのみ実行されます。サーバーレンダリングされたページの初期ハイドレーション時にも clientLoader を強制的に実行したい場合は、clientLoader.hydrate \= true as const; (型推論のため as const を付与) を設定します。この場合も HydrateFallback の提供が必須となります 1。  
* **useLoaderData() フック:**  
  * **規約:** ルートコンポーネントの内部で、そのルートに対応する loader 関数 (データモードの場合) または loader/clientLoader の結果 (フレームワークモードの場合、マージされている可能性あり) から返されたデータにアクセスするために、useLoaderData() フックを使用します 1。  
  * **型安全性:** TypeScript環境では、useLoaderData はジェネリック型を受け付けるか、あるいはフレームワークモードの型生成機能 (+types ファイル) と連携して、返されるデータの型を安全に推論します。  
* **データの型安全性 (フレームワークモード):**  
  * **推奨:** フレームワークモードでは、各ルートモジュールに対応する \+types ディレクトリ内 (例: app/routes/products/+types/route.ts のような規約、あるいはドキュメント例では app/routes/+types/product.ts 1) に型定義ファイルを作成し、loader 関数の引数 (Route.LoaderArgs) や返り値、そしてコンポーネントのプロパティ (Route.ComponentProps 内の loaderData) に対して厳密な型付けを行うことが強く推奨されます 1。これにより、開発時のエラー検知が容易になり、コードの信頼性が向上します。

React Router v7 のデータローディング機構は、データフローの大部分をライブラリが管理することで、開発者が煩雑な状態管理や非同期処理の定型コードから解放されることを目指しています。loader で取得したデータは自動的にシリアライズ・デシリアライズされ、コンポーネントに渡されます。また、後述する action が完了した後には、関連する loader が自動的に再検証されるため 1、UIとデータの一貫性を保つための追加コードが大幅に削減されます。この関心の分離の徹底は、コードのテスト容易性を高め、UIロジックとビジネスロジックの疎結合を促進し、結果としてアプリケーション全体の保守性とスケーラビリティの向上に貢献します。

**Table 3: データ関連APIの概要と責務**

| API/プロパティ | モード | 実行コンテキスト | 主な責務 | 返り値/データアクセス方法 |
| :---- | :---- | :---- | :---- | :---- |
| loader | データ、フレームワーク | サーバー (初期ロード/SSR時)、クライアント (ナビゲーション時フェッチ経由) | ルートコンポーネントレンダリング前のデータ取得 | データオブジェクト / コンポーネント内で useLoaderData() |
| clientLoader | フレームワーク | クライアントブラウザのみ | クライアント専用のデータ取得、オプションでサーバーデータとのマージ | データオブジェクト / コンポーネント内で useLoaderData() |
| action | データ、フレームワーク | 主にサーバー (フォーム送信時など) | データ変更処理 (CUD操作: 作成、更新、削除) | オプショナルなデータ / コンポーネント内で useActionData() |
| clientAction | フレームワーク | クライアントブラウザのみ | クライアント専用のデータ変更処理 | オプショナルなデータ / コンポーネント内で useActionData() |
| useLoaderData() | データ、フレームワーク | クライアント (ルートコンポーネント内) | loader / clientLoader から返されたデータへのアクセス | loader / clientLoader が返したデータ |
| useActionData() | データ、フレームワーク | クライアント (ルートコンポーネント内) | action / clientAction から返されたデータ (例: バリデーションエラー) へのアクセス | action / clientAction が返したデータ |
| useSubmit() | データ、フレームワーク | クライアント (コンポーネントのイベントハンドラ等) | プログラムによるフォーム送信 (対応する action の呼び出し)、ナビゲーションを伴う | \- |
| fetcher.load() | データ、フレームワーク | クライアント (コンポーネント内) | 現在のURLを変更せずに、任意のルートの loader を呼び出してデータを取得 | \- (取得データは fetcher.data でアクセス) |
| fetcher.submit() | データ、フレームワーク | クライアント (コンポーネント内) | 現在のURLを変更せずに、任意のルートの action を呼び出してデータを送信 | \- (アクション結果データは fetcher.data でアクセス) |
| \<Form\> | データ、フレームワーク | クライアント (JSX内) | 宣言的なフォーム送信 (対応する action の呼び出し)、通常ナビゲーションを伴う | \- |
| fetcher.Form | データ、フレームワーク | クライアント (JSX内) | 宣言的なフォーム送信 (対応する action の呼び出し)、ナビゲーションを伴わない | \- |
| shouldRevalidate | データ (主に) | ルートオブジェクト定義時 | loader の自動再検証の実行条件をカスタマイズ | 真偽値 (true で再検証実行) |

この表は、React Router v7 のデータモードおよびフレームワークモードにおける主要なデータ関連APIの役割分担と実行コンテキストを明確にすることで、開発者が状況に応じて最も適切なAPIを選択し、効率的かつ正確にデータハンドリング戦略を実装できるよう支援します。例えば、「ページ遷移なしにバックグラウンドでデータを更新し、UIの一部だけを再描画したい」という要件であれば、fetcher.submit() や fetcher.Form が有力な候補となります。一方、「ページ表示に必要な初期データをサーバーサイドで効率的に取得したい」のであれば、loader がその役割を担います。これらのAPIの特性を深く理解することが、React Router v7 のデータ機能を最大限に活用する鍵となります。

### **3.2. データ送信・アクション (action, clientAction, useSubmit, fetcher, useActionData) (Data Submission/Actions)**

データの作成 (Create)、更新 (Update)、削除 (Delete) といった変更処理（ミューテーション）は、action 関数を中心に扱われます。

* **action (サーバーサイド/共通データミューテーション):**  
  * **規約 (フレームワークモード):** ルートモジュールから action という名前の非同期関数をエクスポートします。この関数は、主にサーバーサイドで実行されるデータ変更処理を担当します 1。  
  * **規約 (データモード):** ルートオブジェクトの action プロパティに非同期関数を指定します 1。  
  * **推奨:** \<Form method="post"\> (または他のHTTPメソッド)、useSubmit() フック、あるいは fetcher.submit() / fetcher.Form から呼び出されます。第一引数として渡される request オブジェクト (標準の Request API に準拠) から await request.formData() のようにしてフォームデータを取得し、データベース更新などの処理を実行します。  
  * **自動再検証:** action 関数が正常に完了すると、React Router は現在のページに表示されているすべての loader データを自動的に再検証（再実行）します。これにより、データ変更後の最新の状態がUIに反映されるため、手動での状態同期処理が不要になります 1。  
* **clientAction (クライアントサイド専用データミューテーション \- フレームワークモード限定):**  
  * **規約:** フレームワークモードにおいて、データ変更処理をクライアントサイドのブラウザ内でのみ実行したい場合に、ルートモジュールから clientAction という名前の非同期関数をエクスポートします 1。例えば、localStorage への書き込みや、クライアントサイドのみで完結する状態の変更などに使用できます。  
  * **優先度:** 同じルートに action (サーバーアクション) と clientAction の両方が定義されている場合、clientAction が優先して実行されます 1。  
* **アクションの呼び出し方法:**  
  * **\<Form\> コンポーネント:** HTMLの \<form\> タグと同様の感覚で、宣言的にアクションを呼び出すことができます。method プロパティ (通常は "post") と、オプションで action プロパティ (送信先のパス、省略時は現在のルート) を指定します。この方法での送信は、デフォルトでページ全体のナビゲーションを伴います 1。  
  * **useSubmit() フック:** JavaScriptのコード内からプログラムによってアクションを呼び出す必要がある場合（例: カスタムUIのボタンクリック時、特定の条件成立時など）に使用します。submit(formData, options) のように呼び出し、これも通常はページ全体のナビゲーションを伴います 1。  
  * **fetcher.Form / fetcher.submit():** ページ全体のナビゲーションやURLの変更を伴わずに、バックグラウンドでアクションを呼び出したい場合に fetcher を使用します。fetcher.Form は宣言的な方法、fetcher.submit() は命令的な方法を提供します。これは、UIの一部分のみを更新するような操作（例: TODOリストのアイテム完了、記事への「いいね」機能、インライン編集の保存など）に非常に適しています 1。  
    * **推奨:** ユーザー体験向上のため、ページ全体の再読み込みが不要なデータ変更操作には fetcher の利用を積極的に検討します。fetcher.state プロパティ ("idle", "submitting", "loading") を監視することで、処理中であることを示すUIフィードバック（例: ボタンの無効化、ローディングスピナーの表示）を容易に実装できます。  
* **useActionData() フック:**  
  * **規約:** ルートコンポーネント内で、そのルートに対応する action 関数 (または clientAction) が返したデータにアクセスするために useActionData() フックを使用します 1。action から返されるデータは、例えばサーバーサイドバリデーションで検出されたエラーメッセージのオブジェクトや、処理成功を示す簡単なメッセージなどです。  
  * **fetcher の場合:** fetcher を使用してアクションを呼び出した場合、アクションからの返り値は fetcher.data プロパティを通じてアクセスできます。  
* **フォームバリデーション:**  
  * **推奨:** フォーム入力値のバリデーションは、対応する action 関数の内部で行うことが推奨されます。バリデーションエラーが検出された場合、エラー情報を含むオブジェクトを action から返し、コンポーネント側では useActionData() (または fetcher.data) でそのエラー情報を取得してユーザーに表示します。詳細なパターンについては、公式ドキュメントの「[フォームのバリデーション](https://react-router-docs-ja.techtalk.jp/how-to/form-validation)」のセクションを参照してください 1。

### **3.3. データ再検証の制御 (shouldRevalidate) (Controlling Data Revalidation \- 主にデータモード)**

React Router は、action の完了後や特定のナビゲーションイベント発生時に、関連する loader のデータを自動的に再検証（再実行）する賢い仕組みを持っています。しかし、この自動的な振る舞いをより細かく制御したい場合があります。

* **規約 (主にデータモード):** データモードで createBrowserRouter に渡すルートオブジェクトの shouldRevalidate プロパティに特定の関数を指定することで、そのルートの loader データが自動再検証されるべきかどうか、そのタイミングをカスタマイズできます 3。  
* **デフォルトの再検証トリガー:** 通常、ルートの loader は以下のような場合に再検証されます 3:  
  * そのルート自身のURLパスパラメータ (例: /products/:id の :id の部分) が変化した場合。  
  * URLの検索パラメータ (クエリ文字列、例: ?sort=price) が変化した場合。  
  * いずれかのルートで action が実行され、正常に完了した場合。  
* **利用シーン:**  
  * パフォーマンス最適化: 特定のURLパラメータの変更が実際には表示データに影響しないことが分かっている場合に、不要な loader の再実行をスキップさせたい。  
  * 特殊な条件下での強制再検証: デフォルトでは再検証されないような特定のナビゲーションイベント（例: 特定の state を伴う遷移）の後に、意図的に再検証をトリガーしたい。  
* **shouldRevalidate 関数の引数:** この関数には ShouldRevalidateFunctionArgs 型のオブジェクトが引数として渡されます。このオブジェクトには、再検証を判断するための情報、例えば currentUrl (現在のURL), nextUrl (遷移先のURL), formMethod (フォーム送信の場合のHTTPメソッド), formData (フォームデータ) などが含まれます 3。  
* **返り値:** shouldRevalidate 関数は真偽値を返します。true を返すとその loader は再検証され、false を返すと再検証はスキップされます。  
* **注意 (フレームワークモードとの差異の可能性):** フレームワークモードにおけるデフォルトの再検証挙動は、データモードと異なる場合があると示唆されています 3。フレームワークモードで shouldRevalidate に相当する詳細な制御方法については、提供された資料からは明確な情報が得られませんでした。  
* 自動再検証は非常に便利な機能ですが、すべてのアプリケーションや状況において最適とは限りません。場合によっては過剰なデータ取得を引き起こし、APIサーバーへの負荷増やフロントエンドのパフォーマンス低下に繋がる可能性があります。shouldRevalidate は、この自動化されたプロセスに介入し、アプリケーション固有のデータ依存関係やビジネスロジックに基づいて再検証の頻度をより精密に制御するための手段を提供します。これにより、不要なAPIコールを削減し、ユーザーエクスペリエンスを向上させることが期待できます。ただし、この制御を誤ると、データが古いままで表示されてしまう（stale data）リスクも伴うため、その影響を十分に理解した上で慎重に設計・実装する必要があります。

## **4\. エラー処理規約 (Error Handling Conventions)**

アプリケーション開発においてエラー処理は不可欠です。React Router v7 は、ルーティングの各段階で発生しうるエラーを捕捉し、ユーザーフレンドリーな方法で処理するための仕組みを提供します。

### **4.1. ErrorBoundary の実装と配置 (Implementing and Placing ErrorBoundary \- 主にフレームワークモード)**

フレームワークモードでは、ルートモジュールごとに専用のエラーUI（エラー境界）を定義することが推奨されます。

* **規約 (フレームワークモード):** 各ルートモジュール（例: app/routes/some-feature.tsx）は、そのルート自身およびその子ルート群で発生したエラー（loader や action でのスロー、レンダリング中のエラーなど）を捕捉し、カスタムUIを表示するために、ErrorBoundary という名前のReactコンポーネントをエクスポートすることができます \[1 (Error Boundary Details), 11\]。  
* **規約 (ルートレベルのエラー境界):** アプリケーション全体の「ルート」となるコンポーネント（通常は app/root.tsx に対応）には、必ず包括的な ErrorBoundary を設定します。これにより、アプリケーションのどこかで予期せぬエラーが発生した場合でも、ユーザーに空白のページやクラッシュした画面が表示されるのを防ぎ、最低限のエラー情報やナビゲーションを提供できます \[1 (Error Boundary Details {S149})\]。  
* **エラーの種別に応じた表示の切り替え:** ErrorBoundary コンポーネントの内部では、useRouteError() フック（後述）を使って発生したエラーオブジェクトを取得します。その後、エラーオブジェクトの型やプロパティをチェックし（例: isRouteErrorResponse(error) でHTTPエラーレスポンスかどうかを判定、error instanceof Error で標準的なJavaScriptエラーかどうかを判定）、エラーの種類に応じて表示するメッセージやUIを動的に切り替えることが推奨されます \[1 (Error Boundary Details {S154, S155, S156})\]。  
* **ネストされたエラー境界の挙動:** エラーが発生すると、React Router はコンポーネントツリーを遡り、そのエラーを捕捉できる最も近い親の ErrorBoundary をレンダリングします \[1 (Error Boundary Details {S165-S169})\]。これにより、エラーの影響範囲を特定のセクションに局所化し、アプリケーションの他の部分は引き続き機能するように設計できます。例えば、記事詳細ページでエラーが発生しても、サイト全体のヘッダーやナビゲーションは表示し続ける、といった制御が可能です。  
* **コード例 (app/root.tsx での包括的な ErrorBoundary):**  
  TypeScript  
  // app/root.tsx (フレームワークモード)  
  import {  
    Links,  
    Meta,  
    Outlet,  
    Scripts,  
    ScrollRestoration,  
    isRouteErrorResponse, // React Router DOM からインポート  
    useRouteError,        // React Router DOM からインポート  
  } from "react-router-dom"; // インポート元はプロジェクト設定に依存する可能性あり

  export function ErrorBoundary() {  
    const error \= useRouteError(); // useRouteErrorフックでエラーオブジェクトを取得

    let heading \= "予期せぬエラーが発生しました";  
    let message \= "申し訳ありませんが、アプリケーションの処理中に問題が発生しました。";  
    let details \= null;

    if (isRouteErrorResponse(error)) { // loader や action から throw された Response オブジェクトの場合  
      heading \= \`${error.status} ${error.statusText}\`;  
      switch (error.status) {  
        case 401: message \= "このページにアクセスするには認証が必要です。"; break;  
        case 404: message \= "お探しのページは見つかりませんでした。"; break;  
        case 500: message \= "サーバー内部でエラーが発生しました。"; break;  
        default: message \= error.data?.message |

| "リクエストの処理中にエラーが発生しました。";  
}  
if (error.data?.stack && process.env.NODE\_ENV \=== "development") { // 開発モードでのみスタックトレース  
details \= \<pre\>{error.data.stack}\</pre\>;  
}  
} else if (error instanceof Error) { // 標準的な JavaScript Error オブジェクトの場合  
message \= error.message;  
if (process.env.NODE\_ENV \=== "development") { // 開発モードでのみスタックトレース  
details \= \<pre\>{error.stack}\</pre\>;  
}  
} else {  
// その他の予期せぬ形式のエラー  
if (process.env.NODE\_ENV \=== "development") {  
details \= \<pre\>{JSON.stringify(error, null, 2)}\</pre\>;  
}  
}

  return (  
    \<html lang="ja"\>  
      \<head\>  
        \<Meta /\>  
        \<Links /\>  
        \<title\>{heading}\</title\>  
      \</head\>  
      \<body\>  
        \<h1\>{heading}\</h1\>  
        \<p\>{message}\</p\>  
        {details}  
        \<Scripts /\>  
      \</body\>  
    \</html\>  
  );  
}  
\`\`\`  
上記コード例は \[\[1\] (Error Boundary Details {S153-S156})\] の概念を参考に、\`useRouteError\` を明示的に使用し、より実践的なエラーメッセージの分岐と開発モードでの詳細表示を含める形に改変しています。

* **注意:** エラー境界は、フォームの入力バリデーションエラー（例: 「メールアドレスの形式が正しくありません」）の表示や、アプリケーションの通常の制御フロー（例: 特定の条件で特定のエラーページに意図的に遷移させる）の手段として使用することを主目的とはしていません \[1 (Error Boundary Details {S148, S157, S158})\]。これらは主に、予期せぬランタイムエラーや、loader/action からスローされた捕捉すべきエラーを処理するためのものです。

### **4.2. errorElement プロパティと useRouteError フックの活用 (Utilizing errorElement and useRouteError)**

エラー情報を取得し、それに基づいてUIを表示するための主要なAPIです。

* **useRouteError() フック:**  
  * **規約:** フレームワークモードでルートモジュールからエクスポートされた ErrorBoundary コンポーネントの内部、またはデータモードのルートオブジェクトで errorElement プロパティとして指定されたReact要素（コンポーネント）の内部で、発生したエラーオブジェクトそのものにアクセスするために useRouteError() フックを使用します 1。このフックが返すエラーオブジェクトの型や内容は、エラーの発生源（例: loader からの throw new Response(...)、レンダリング中のJavaScriptエラーなど）によって異なります。  
* **errorElement プロパティ (データモードのルートオブジェクト / \<Await\> コンポーネント):**  
  * **規約 (データモード \- 推測と注意を含む):** データモードで createBrowserRouter に渡すルートオブジェクトに、errorElement プロパティとしてReact要素（例: \<MyCustomErrorPage /\>）を指定することで、そのルート（およびその子ルートで捕捉されなかったエラー）でエラーが発生した際にレンダリングされるフォールバックUIを定義します。この errorElement として指定されたコンポーネント内では、useRouteError() を使ってエラーの詳細を取得できます。  
    * **情報不足に関する強い警告:** 提供された資料からは、データモードのルートオブジェクトにおける errorElement プロパティの具体的なAPI仕様、推奨される使用法、または ErrorBoundary との使い分けについての詳細な説明が決定的に不足しています 3。4 は \<Await\> コンポーネントの errorElement について言及しており、これはルート定義の errorElement とは異なるコンテキストである可能性があります。したがって、データモードで errorElement を使用する際は、React Router の最新の公式ドキュメントでその仕様を必ず確認し、十分なテストを行うことが強く推奨されます。本規約では、この機能が存在し、期待通りに機能すると仮定して記述していますが、その確証はありません。  
  * **規約 (\<Await\> コンポーネント):** \<Await\> コンポーネントは、loader から返されたPromiseの解決を待つために使用されます。この resolve プロパティに渡されたPromiseがリジェクト（失敗）した場合に、children の代わりにレンダリングされるフォールバックUIを、\<Await\> の errorElement プロパティで指定します 4。  
    * **コード例 (\<Await\> コンポーネントでの errorElement の使用):**  
      JavaScript  
      import React from "react"; // React.Suspense のため  
      import { Await, useLoaderData } from "react-router-dom"; // インポート元は適宜調整  
      // import ReviewsDisplay from "./ReviewsDisplay"; // 仮のコンポーネント  
      // import LoadingSpinner from "./LoadingSpinner"; // 仮のコンポーネント

      function ProductDetailsPage() {  
        const data \= useLoaderData(); // loader から reviewsPromise を含むデータが返されると仮定

        return (  
          \<div\>  
            \<h2\>製品レビュー\</h2\>  
            \<React.Suspense fallback\={\<p\>レビューセクションを準備中...\</p\> /\* LoadingSpinner \*/}\>  
              \<Await  
                resolve\={data.reviewsPromise} // loader から返されたレビュー取得のPromise  
                errorElement\={\<p style\={{ color: "red" }}\>レビューの読み込み中にエラーが発生しました。\</p\>}  
              \>  
                {(resolvedReviews) \=\> (  
                  \<ul\>  
                    {/\* {resolvedReviews.map(review \=\> \<li key\={review.id}\>{review.text}\</li\>)} \*/}  
                    {/\* \<ReviewsDisplay reviews\={resolvedReviews} /\> \*/}  
                    {JSON.stringify(resolvedReviews)}  
                  \</ul\>  
                )}  
              \</Await\>  
            \</React.Suspense\>  
          \</div\>  
        );  
      }  
      上記コード例は 4 の情報を基に、\<Await\> コンポーネントの文脈で errorElement がどのように使用されるかを示しています。

React Router v7 は、ルートレベルでのエラー処理を重視しており、ErrorBoundary (フレームワークモード) や errorElement (データモードの可能性、\<Await\>) を通じて、エラー発生時のUIを制御する統一的な仕組みの提供を目指しているように見えます。useRouteError は、これらのエラーUIコンポーネントが具体的なエラー情報にアクセスするための共通の手段として機能します。この設計により、アプリケーション全体がクラッシュするのを防ぎ、ユーザーに対して「データが見つかりませんでした（404）」、「サーバーで問題が発生しました（500）」、「認証が必要です（401）」といった、より具体的で親切なフィードバックを提供することが可能になります。ただし、モードによってエラー処理の具体的な実装方法（ErrorBoundary のエクスポート 対 errorElement プロパティ）に違いがある可能性があり、特にドキュメントの情報が不透明な部分（データモードの errorElement など）については、開発チーム内での十分な検証と、エラー処理戦略の統一が、堅牢なアプリケーションを構築する上で不可欠です。

### **4.3. loader/action 内でのエラーハンドリング (Error Handling within loader/action)**

loader 関数や action 関数は、データ取得やデータ変更処理中にエラーが発生する可能性がある主要な場所です。これらの関数内でエラーを適切に処理し、スローすることが重要です。

* **意図的なエラーレスポンスのスロー:**  
  * **規約:** loader や action の処理中に、特定の状況（例: リクエストされたリソースが見つからない場合はHTTP 404エラー、ユーザーに必要な権限がない場合はHTTP 403エラー、入力バリデーションエラーの場合はHTTP 400エラーなど）を示すために、意図的にエラーレスポンスをスローすることが推奨されます。このエラーレスポンスは、通常、標準の Response オブジェクトを throw するか、React Router が提供するユーティリティ（例: json, redirect など、これらも内部で Response を生成します）を throw することで行います。  
  * **推奨される実践 (\[**1 **(Error Boundary Details {S162, S163})\]):** 例えば、loader が params.id に基づいてデータベースからレコードを取得しようとして見つからなかった場合、単に null や undefined を返すのではなく、throw new Response("Not Found", { status: 404 }); や、より情報量の多いJSONレスポンスとして throw json({ message: "指定されたリソースは見つかりませんでした。", resourceId: params.id }, { status: 404 }); のように、適切なHTTPステータスコードと、可能であればエラーに関する追加情報を含むレスポンスをスローします。これにより、対応する ErrorBoundary または errorElement がこのレスポンスを useRouteError() で受け取り、isRouteErrorResponse() で判定して、ユーザーに適切なエラーメッセージ（例: 「お探しのページは見つかりませんでした」）を表示できます。  
  * **非推奨:** アプリケーションの通常の制御フローの手段として、予期せぬ一般的なJavaScriptエラー (Error インスタンスなど) を意図的にスローすることは避けるべきです \[1 (Error Boundary Details {S157})\]。エラー境界は、主にコード内の予期せぬバグや、捕捉すべきHTTPエラーレスポンスを処理するために設計されています。  
* **エラーのサニタイズ (本番環境での挙動):**  
  * **規約:** 本番モード (production build) でアプリケーションが動作している場合、サーバーサイド（または loader/action の実行環境）で発生した一般的な Error インスタンス（例: throw new Error("データベース接続エラー");）は、クライアント（ブラウザ）に送信される前に、React Router によって自動的にサニタイズ（無害化）されます。具体的には、エラーメッセージは一般的なもの（例: "An unexpected error occurred."）に置き換えられ、機密情報を含む可能性のあるスタックトレースはクライアントには送信されません \[1 (Error Boundary Details {S170, S171})\]。これは、サーバー内部の実装詳細や潜在的な脆弱性が外部に漏洩するのを防ぐためのセキュリティ措置です。  
  * **例外:** throw new Response(...) や throw json(...)、throw redirect(...) のように、意図的に Response オブジェクトとしてスローされたデータ（エラーメッセージやステータスコードを含む）は、クライアント側で表示されることを意図しているため、この自動サニタイズの対象外となります \[1 (Error Boundary Details {S173})\]。

### **4.4. サーバーサイドエラー報告 (handleError) (Server-Side Error Reporting \- フレームワークモード限定)**

フレームワークモードでは、サーバーサイドで発生し、React Router によって捕捉されたエラーを、外部の監視サービス（例: Sentry, Datadog, LogRocketなど）に報告するための専用のフックが提供されています。

* **規約:** フレームワークモードで開発されたアプリケーションにおいて、サーバーサイドで発生したエラーを一元的にロギングしたり、外部のエラー監視システムに通知したりするためには、サーバーエントリーファイル（通常は entry.server.tsx または entry.server.jsx）から handleError という名前の関数をエクスポートします \[1 (Error Reporting Details {S139, S141})\]。この関数は、React Router がサーバー上でエラーを捕捉するたびに呼び出されます。  
* **実装の詳細:** handleError 関数は、第一引数として捕捉された error オブジェクトを、第二引数として現在のリクエストに関する情報（request オブジェクトを含むオブジェクト）を受け取ります。この関数内で、受け取ったエラー情報を整形し、コンソールへの出力、ファイルへのロギング、または外部の監視サービスへ送信する処理を実装します \[1 (Error Reporting Details {S141})\]。  
* **中断されたリクエストの除外:** React Router は、クライアントがナビゲーションを中断した場合などに、進行中のリクエストを中止 (abort) することがあります。このような中止されたリクエストに起因するエラーは、通常のアプリケーションエラーとは区別し、エラー報告の対象外とすることを検討できます。これは、request.signal.aborted が true かどうかをチェックすることで判断できます \[1 (Error Reporting Details {S141})\]。  
* **サーバーエントリーファイルの公開 (カスタマイズのため):** もしプロジェクトのルートディレクトリに entry.server.tsx (または .jsx) ファイルが見当たらない場合、それはReact Router がデフォルトのサーバーエントリーを使用していることを意味します。handleError をカスタマイズするためには、まず npx react-router reveal entry.server のようなCLIコマンド（正確なコマンドはプロジェクト設定やReact Routerのバージョンにより異なる場合があります。ドキュメントでは react-router reveal と記載 \[1 (Error Reporting Details {S140})\]) を実行して、デフォルトのサーバーエントリーファイルをプロジェクト内に明示的に生成（reveal）し、そのファイルを編集する必要があります。  
* **コード例 (entry.server.tsx 内の handleError):**  
  TypeScript  
  // entry.server.tsx (フレームワークモード)  
  import type { HandleErrorFunction } from "@remix-run/node"; // または適切な react-router の型定義元  
  // import \* as Sentry from "@sentry/remix"; // Sentry などのエラー報告ライブラリをインポートする例

  // Sentry.init({ /\* Sentry の設定 \*/ }); // エラー報告ライブラリの初期化

  export const handleError: HandleErrorFunction \= (  
    error: unknown, // エラーオブジェクト (型は様々)  
    { request }: { request: Request } // リクエストオブジェクト  
  ) \=\> {  
    // 中断されたリクエストによるエラーは報告しない  
    if (request.signal.aborted) {  
      return;  
    }

    // まずコンソールにエラーを出力 (ローカル開発や基本的なログ確認のため)  
    console.error("SSR Error caught in handleError:", error);  
    console.error("Request URL:", request.url);  
    console.error("Request Method:", request.method);

    // 外部のエラー報告サービスに送信 (例: Sentry)  
    // if (error instanceof Error) {  
    //   Sentry.captureRemixServerException(error, "handleError", request);  
    // } else {  
    //   Sentry.captureException(error, {  
    //     extra: {  
    //       remixFlow: "handleError",  
    //       requestUrl: request.url,  
    //       requestMethod: request.method,  
    //     },  
    //   });  
    // }  
  };  
  上記コード例は \[1 (Error Reporting Details {S141})\] の概念を基に、より具体的なロギングや外部サービス連携の可能性を示唆する形で構成しています。実際の型定義やライブラリ連携部分は、使用するReact Routerのバージョンや環境（Remixベースか、Viteプラグインベースかなど）によって異なります。

## **5\. コード分割と遅延読み込み規約 (Code Splitting and Lazy Loading Conventions)**

アプリケーションの初期ロードパフォーマンスを向上させるためには、JavaScriptバンドルのサイズを削減し、必要なコードのみを効率的に読み込む戦略が不可欠です。React Router v7 は、このための強力な機能を提供します。

### **5.1. 自動コード分割の活用 (Leveraging Automatic Code Splitting \- フレームワークモード限定)**

フレームワークモードでは、開発者が特別な設定を行うことなく、ルートベースの自動コード分割の恩恵を受けることができます。

* **規約と動作:** フレームワークモードにおいて、app/routes.ts (またはファイルシステムルーティング) で参照される各ルートモジュール（例: app/routes/dashboard.tsx, app/routes/profile.tsx）は、ビルドプロセスによって自動的に独立したJavaScriptチャンク（バンドルエントリーポイント）として扱われます \[1 (Code Splitting Details {S130})\]。  
* **利点:** このルート単位のコード分割により、ユーザーが特定のURLに初めてアクセスした際に、そのルートのレンダリングに必要なJavaScriptコードのみがブラウザにダウンロード・実行されます。アプリケーション全体のすべてのコードを単一の巨大なバンドルとして読み込む必要がなくなるため、初期ロード時のJavaScriptフットプリントが大幅に削減され、Time To Interactive (TTI) や First Contentful Paint (FCP) といった主要なウェブパフォーマンス指標が改善されます \[1 (Code Splitting Details {S130})\]。  
* **サーバーコードの自動削除:** フレームワークモードのもう一つの重要な最適化として、ルートモジュール内に記述されたサーバー専用のAPI（具体的には loader 関数、action 関数、headers 関数など）は、クライアントサイド向けのJavaScriptバンドルからは自動的に削除されます \[1 (Code Splitting Details {S130})\]。これにより、クライアントに不要なコードが送信されるのを防ぎ、バンドルサイズをさらに削減するとともに、サーバーサイドのロジックや機密情報がクライアントに漏洩するリスクも低減します。  
* **推奨:** この自動コード分割とサーバーコード削除の機能を最大限に活用するためには、アプリケーションの機能を論理的なルート単位に分割し、各ルートに関連するUI、データ取得ロジック、データ変更ロジックを、対応するルートモジュール内に適切に配置することが推奨されます。  
* フレームワークモードにおけるこれらの自動最適化は、React Router (特に Remix の設計思想を受け継ぐ部分) が、開発者が煩雑なパフォーマンスチューニングに多くの時間を費やすことなく、デフォルトで高いパフォーマンスを発揮できるアプリケーションを構築できるように支援するという思想の表れです。ルート単位でのコード分割は、ユーザーが最初に訪れるページに無関係な他ページのコードが読み込まれるのを防ぎ、特にモバイルユーザーやネットワーク環境が不安定なユーザーの体験を大幅に改善します。開発者は、これらの基盤となる最適化の恩恵を受けつつ、よりアプリケーション固有の機能開発やビジネスロジックの実装に集中することができます。

### **5.2. lazy プロパティによる遅延読み込みの実装 (Implementing Lazy Loading with the lazy Property \- データモード/フレームワークモード)**

データモードおよびフレームワークモードでは、ルート定義の lazy プロパティを利用して、特定のルートに関連するモジュール（コンポーネント、loader、action など）の読み込みを、そのルートが実際にアクセスされるまで遅延させることができます。

* **規約:** データモードのルートオブジェクト、またはフレームワークモードの app/routes.ts 内でのルート定義（route() ヘルパーなどを使用する場合）において、lazy プロパティを使用します。このプロパティには、動的な import() 式を含む非同期関数を値として指定します 3。  
* **目的と効果:** lazy を使用することで、アプリケーションの初期起動時にすべてのルートのコードを読み込むのではなく、ユーザーが特定のルートにナビゲートした時点で初めて、そのルートに必要なモジュールがネットワーク経由でダウンロード・実行されるようになります。これにより、初期バンドルサイズが顕著に削減され、アプリケーションの初回ロード時間が短縮され、全体的なユーザーエクスペリエンスが向上します。  
* **実装方法:** lazy プロパティに渡す非同期関数は、そのルートがマッチした際に呼び出されます。この関数内では、await import("./path/to/YourComponent") のようにして、ルートコンポーネントや、そのルートで使用される loader 関数や action 関数を含むモジュールを動的にインポートします。複数のモジュールをインポートする必要がある場合は、Promise.all を使用して並行して読み込むことで、効率を高めることができます。非同期関数は、最終的に { Component, loader, action,... } のような、ルート定義に必要なプロパティを含むオブジェクトを返す必要があります 3。  
* **コード例 (データモードでの lazy 利用):**  
  JavaScript  
  // データモード: createBrowserRouter に渡すルートオブジェクトの配列内  
  import { createBrowserRouter } from "react-router-dom";

  const router \= createBrowserRouter(  
    },  
    // 他のルート定義...  
  \]);  
  上記コードは 3 及び 3 の情報を参考に、より階層的な遅延読み込みの可能性を示唆する形で構成しています。  
* **フォールバックUIの提供:**  
  * **推奨:** 遅延読み込みされるモジュールがダウンロード・解析されている間、ユーザーには何らかのローディング状態を示すUI（例: ローディングスピナー、スケルトンプレースホルダー）を表示することが強く推奨されます。これは、React の標準機能である \<Suspense\> コンポーネントを、遅延読み込みされるルートコンポーネントをレンダリングする \<Outlet /\> の上位階層の適切な場所に配置し、その fallback プロパティにローディングUIを指定することで実現できます 3。  
  * **フレームワークモードでの HydrateFallback との関連:** フレームワークモードで clientLoader を使用する場合、ルートモジュールから HydrateFallback をエクスポートしてローディングUIを提供します 1。lazy プロパティによる遅延読み込みと clientLoader を併用する場合の具体的なフォールバック戦略（\<Suspense\> と HydrateFallback のどちらが優先されるか、あるいは両方必要かなど）については、React Router の公式ドキュメントで詳細なガイダンスを確認する必要があります。  
* **注意点と考慮事項:**  
  * **エラーハンドリング:** lazy で動的にインポートされるモジュールの読み込み中にネットワークエラーなどが発生した場合に備えて、適切なエラー境界 (ErrorBoundary または errorElement) を設定しておくことが重要です 3。\<Suspense\> とエラー境界を組み合わせることで、ローディング中のエラーも適切に処理できます。  
  * **チャンクの粒度:** lazy を使用する単位（チャンクの粒度）は慎重に検討する必要があります。あまりにも細かく分割しすぎると、初期バンドルサイズは小さくなるものの、ナビゲーションのたびに多数の小さなJavaScriptファイルがリクエストされることになり、HTTPリクエストのオーバーヘッドやカスケード的な読み込みによって、かえってユーザーエクスペリエンスを損なう可能性があります。主要な機能エリアごとや、ユーザーが頻繁にはアクセスしない独立したセクションごとなど、意味のある単位で分割することを検討します。

## **6\. ルート保護とセキュリティ規約 (Route Protection and Security Conventions)**

アプリケーションの特定の部分（例: 管理画面、ユーザープロファイルページなど）へのアクセスを認証済みユーザーのみに制限したり、その他のセキュリティ対策を施したりすることは、多くのウェブアプリケーションで不可欠な要件です。

### **6.1. loader を利用した認証ベースのリダイレクト (Authentication-Based Redirection using loader)**

React Router v7 の loader 関数は、ルートコンポーネントがレンダリングされる前に実行されるため、認証チェックと、その結果に基づいたリダイレクト処理を実装するのに適した場所です。

* **規約:** 保護したいルート（認証が必要なページに対応するルート）の loader 関数内で、まずユーザーの認証状態を確認します。未認証であると判断された場合は、ログインページなどの適切なURLへリダイレクトさせるための Response オブジェクトを redirect() ユーティリティを使って生成し、それを loader 関数の返り値（または throw する値）とします 1。  
* **実装ステップ:**  
  1. **認証情報の取得:** loader 関数の第一引数として渡される request オブジェクト（標準の Request API に準拠）から、認証情報（例: HTTPヘッダー内の Authorization トークン、クッキーに保存されたセッションIDなど）を取得します。具体的な取得方法は、アプリケーションが採用している認証戦略（例: JWT、OAuth、セッションベース認証など）に大きく依存します。  
     * **情報不足に関する注記:** ユーザー認証の具体的な実装方法や、loader 内でContext APIや外部の認証ライブラリと連携する方法については、提供された資料からは詳細な情報が得られませんでした 9。本規約では、redirect を用いた基本的なリダイレクトパターンに焦点を当てます。  
  2. **認証状態の検証:** 取得した認証情報を検証し、ユーザーが有効なセッションを持っているか、または必要な権限を有しているかを確認します。  
  3. **リダイレクト処理:** 未認証または権限不足と判断された場合、redirect(loginPath) を呼び出してログインページへのリダイレクトレスポンスを生成し、それを返します。オプションとして、ログイン後に元のページに戻れるように、現在のURLをログインページのクエリパラメータとして渡すことも一般的です (例: /login?redirectTo=/protected-page)。  
  4. **データ取得 (認証済みの場合):** ユーザーが認証済みである場合は、通常のデータ取得処理を継続し、その結果を返します。  
* **コード例 (フレームワークモードまたはデータモードの loader 関数内):**  
  TypeScript  
  import { redirect, json } from "react-router-dom"; // または "react-router"  
  // import { getSessionFromCookie, verifyUserToken } from "./auth.server"; // サーバーサイドでセッション/トークンを処理するユーティリティ関数（仮定）

  export async function loader({ request }: { request: Request }) {  
    // const sessionCookie \= request.headers.get("Cookie");  
    // const session \= await getSessionFromCookie(sessionCookie);  
    const session \= { user: null }; // 仮のセッションオブジェクト (未認証状態)

    // if (\!session ||\!session.user ||\!(await verifyUserToken(session.user.token))) {  
    if (\!session.user) { // 単純化された認証チェック  
      const currentPathname \= new URL(request.url).pathname;  
      const loginUrl \= new URL("/login", request.url);  
      if (currentPathname\!== "/") { // ルートパスへのリダイレクトループを避ける  
        loginUrl.searchParams.set("redirectTo", currentPathname);  
      }

      // redirect を throw するか return するかはプロジェクトの規約や型定義との相性で選択  
      throw redirect(loginUrl.toString());  
    }

    // 認証済みユーザー向けのデータを取得して返す  
    // const protectedData \= await fetchProtectedDataForUser(session.user.id);  
    // return json({ user: session.user, data: protectedData });  
    return json({ user: session.user, message: "認証済みユーザー向けのデータです" });  
  }  
  上記コードは 8 及び 1 の例を参考に、より具体的な認証フローを想定して記述しています。実際の認証ロジックはアプリケーションの要件に応じて複雑になります。

loader を利用した認証チェックは、ルートのコンテンツがクライアントに送信される前にサーバーサイド（またはそれに準じる環境）でアクセス制御が行われるため、クライアントサイドのみで行うガード処理と比較して、よりセキュアな保護を提供します。未認証ユーザーは、保護されたルートのコンポーネントがレンダリングされる前にリダイレクトされるため、機密性の高いデータやUIが意図せず漏洩するリスクを効果的に低減できます。このアプローチは、伝統的なサーバーサイドウェブアプリケーションにおける認証フローと概念的に類似しており、理解しやすいという利点があります。一方で、この方法は主にルート遷移時のアクセス制御に焦点を当てており、既に表示されているページ内での動的なUIの変更（例: ユーザーのログイン状態に応じてヘッダーの表示内容を切り替えるなど）や、より複雑なロールベースアクセス制御 (RBAC) を実現するには、loader だけでは不十分な場合があります。そのような場合は、クライアントサイドでの状態管理（Context APIや状態管理ライブラリの利用）や、Remixの handle のようなルートメタデータ機能（React Router v7で同等の機能が提供されていれば）との組み合わせを検討する必要があります。

### **6.2. Content-Security-Policy (CSP) と nonce の設定 (Configuring CSP and nonce \- フレームワークモード推奨)**

Content-Security-Policy (CSP) は、クロスサイトスクリプティング (XSS) やその他のコードインジェクション攻撃を防ぐための重要なセキュリティレイヤーです。React Router v7 (特にサーバーサイドレンダリングを行うフレームワークモード) を使用する際にCSPを導入する場合、いくつかの設定に注意が必要です。

* **規約:** アプリケーションでCSPを導入し、特にインラインスクリプトの実行を制限するポリシー（例: script-src ディレクティブで 'unsafe-inline' を許可しない）を適用する場合、React Router がHTMLドキュメント内にレンダリングするインライン \<script\> タグに対して、リクエストごとに生成されるユニークな nonce (number used once) 属性を指定する必要があります \[1 (Security Details {S140, S141})\]。  
* **nonce 指定が必要な主要API:** 以下のAPI（主にフレームワークモードのサーバーサイドレンダリング関連）で nonce プロパティまたはオプションを指定します。cspNonce はサーバーで生成された実際のnonce値に置き換えます。  
  * ルートコンポーネント (app/root.tsx など) 内:  
    * \<Scripts nonce={cspNonce} /\> \[1 (Security Details {S42})\]  
    * \<ScrollRestoration nonce={cspNonce} /\> \[1 (Security Details {S43})\]  
  * サーバーエントリーファイル (entry.server.tsx など) 内:  
    * \<ServerRouter nonce={cspNonce} /\> (もし使用している場合) \[1 (Security Details {S44})\]  
    * React DOM Server API の呼び出し時:  
      * renderToPipeableStream(reactApp, {..., nonce: cspNonce }) \[1 (Security Details {S142})\]  
      * renderToReadableStream(reactApp, {..., nonce: cspNonce }) (もし使用している場合) \[1 (Security Details {S143})\]  
* **nonce の生成とHTTPヘッダーでの伝達:**  
  1. サーバーサイドで、各HTTPリクエストに対して暗号学的に安全なランダムな文字列として nonce 値を生成します（例: 128ビット以上のランダムなbase64エンコード文字列）。  
  2. 生成した nonce 値を、HTTPレスポンスの Content-Security-Policy ヘッダー内の script-src ディレクティブ（および必要であれば style-src など他のディレクティブ）に含めます。例: Content-Security-Policy: script-src 'self' 'nonce-YOUR\_GENERATED\_NONCE\_VALUE' https://trusted.cdn.com;...  
  3. 同じ nonce 値を、上記でリストアップしたReact RouterおよびReact DOM Server APIの nonce プロパティ/オプションに渡します。  
* **推奨:** CSPはXSS攻撃に対する非常に効果的な多層防御の一つです。可能な限り厳格なポリシー（例: デフォルトでインライン実行や eval を禁止し、信頼できるソースのみをホワイトリスト登録する）を設定し、インラインスクリプトが必要な場合は nonce ベースまたはハッシュベースのアプローチを採用することを強く推奨します。  
* **注意:** ここで提供する情報は、React Router の機能がCSPとどのように関連するかに焦点を当てたものであり、CSP自体の包括的な設定ガイドではありません \[1 (Security Details {S125})\]。CSPの導入と維持は複雑な場合があるため、MDN Web Docsなどの信頼できるリソースを参照し、アプリケーションの具体的な要件に合わせて慎重にポリシーを設計・テストしてください。

## **7\. 主要APIコンポーネント・フック・ユーティリティ利用規約 (Conventions for Key API Components, Hooks, and Utilities)**

React Router v7 は、ルーティング機能を構築するための多様なコンポーネント、フック、ユーティリティを提供しています 1。これらを規約に沿って適切に使用することで、コードの可読性、保守性、および再利用性が向上します。

* **\<Outlet /\> コンポーネント:**  
  * **規約:** 親ルートコンポーネントのJSX内で、ネストされた子ルートコンポーネントがレンダリングされるべき場所を指定するために \<Outlet /\> を配置します 1。親ルートがレイアウトとしての役割を果たす場合、この \<Outlet /\> が子ページのコンテンツの挿入ポイントとなります。  
  * **コンテキストの共有:** 親ルートからその直下の子ルートへ特定のデータや関数を渡したい場合、\<Outlet context={...} /\> のように context プロパティを使用できます。子ルート側では useOutletContext() フックを使ってこのコンテキストデータにアクセスできます 1。  
* **\<ScrollRestoration /\> コンポーネント:**  
  * **規約:** ブラウザの履歴を「戻る/進む」でナビゲートした際に、スクロール位置を以前の状態に復元する機能を提供します。通常、アプリケーションの最上位のルートコンポーネント（例: フレームワークモードの app/root.tsx）内に一度だけ配置します 1。  
  * **nonce 属性:** Content-Security-Policy (CSP) を使用している場合は、前述のセキュリティ規約に従い、nonce プロパティに適切な値を指定します \[1 (Security Details {S43})\]。  
* **useParams() フック:**  
  * **規約:** 現在アクティブなルートのURLパスから、動的セグメント（例: /users/:userId の :userId の部分）の実際の値を取得するために、ルートコンポーネントまたはその子孫コンポーネント内で useParams() フックを使用します 1。返り値は、動的セグメント名をキーとし、その値を文字列として持つオブジェクトです。  
* **useSearchParams() フック:**  
  * **規約:** 現在のURLのクエリ文字列（検索パラメータ、例: ?query=abc\&sort=date）を読み取ったり、プログラムによって変更したりするために useSearchParams() フックを使用します 1。  
  * **推奨:** 検索機能、フィルタリングオプション、ページネーション、ソート順の指定など、ユーザーが操作可能な状態をURLに反映させ、そのURLをブックマーク可能にしたり他者と共有可能にしたりしたい場合に積極的に活用します。このフックは \`\` という形式の配列を返します。searchParams は現在の検索パラメータを読み取るための URLSearchParams インスタンスであり、setSearchParams は検索パラメータを更新するための関数です。  
* **useLocation() フック:**  
  * **規約:** 現在のロケーション（URL）に関する詳細情報を含むオブジェクトを取得するために useLocation() フックを使用します 1。このロケーションオブジェクトには、pathname (パス名)、search (クエリ文字列)、hash (ハッシュフラグメント)、state (ナビゲーション時に渡された状態)、key (ロケーションの一意なキー) といったプロパティが含まれます。  
  * **注意と代替手段の検討:** useLocation().pathname の変更を useEffect の依存配列に含めて副作用（例: ページビューのトラッキング）を実行する、といった使い方が考えられます。しかし、React Router v7 のデータフロー機能（loader や action）が充実しているため、ロケーションの変更に直接反応するロジックの多くは、これらの機能や他の専用フックでより宣言的かつ効率的に代替できる可能性があります。useLocation の直接的な利用は、本当にロケーションオブジェクト自体へのアクセスが必要な場合に限定することを検討します。  
* **useMatches() フック:**  
  * **規約:** 現在のURLにマッチしているすべてのルート（親ルートから最も深くネストした子ルートまで）に関する情報の配列を取得するために useMatches() フックを使用します 1。配列の各要素（マッチオブジェクト）には、そのルートの id (ルートにIDが設定されていれば)、pathname (マッチしたパス部分)、params (そのルートでキャプチャされた動的セグメントの値)、data (そのルートの loader から返されたデータ)、handle (ルートに定義されたカスタムハンドルオブジェクト) といった情報が含まれます 10。  
  * **利用シーン:** パンくずリスト (Breadcrumbs) の動的な生成（各マッチオブジェクトからパス名やタイトルを取得する）、現在のルート階層に基づいて特定のUI要素（例: ヘッダーのタイトル、サイドバーのコンテンツ）を動的に変更したい場合などに有用です。  
* ユーティリティ関数 (例: generatePath, matchPath):  
  React Router は、ルーティング関連の一般的なタスクを助けるいくつかのユーティリティ関数も提供しています 1。  
  * **generatePath(pattern: string, params?: Params): string:**  
    * **規約:** 指定されたパスパターン文字列（例: /users/:userId/posts/:postId）と、動的セグメントに対応する値を持つ params オブジェクトから、実際のURL文字列をプログラムによって生成します。  
    * **推奨:** アプリケーション内で特定のルートへのリンクを動的に生成する必要がある場合（特に、パスパラメータが変数である場合）に、URL文字列を手動で結合する代わりにこのユーティリティを使用することで、タイプミスを防ぎ、パスパターンの変更にも追従しやすくなります。型安全なパス生成ライブラリ（例: pathpida や自作の型付きヘルパー）と組み合わせることで、さらに堅牢性を高めることができます。  
  * **matchPath(pattern: PathPattern | string, pathname: string): PathMatch | null:**  
    * **規約:** 指定されたURLパス名 (pathname) が、与えられたパスパターン (pattern) にマッチするかどうかを判定します。マッチした場合は、マッチした部分のパスやパラメータを含む PathMatch オブジェクトを返し、マッチしなかった場合は null を返します。  
    * **利用シーン:** React Router のルーティングシステムの外部で（例えば、カスタムのミドルウェアや、Reactコンポーネントツリー外のロジックで）、特定のパスに対するカスタム処理を行いたい場合など、限定的な状況で使用されることがあります。通常は、React Router の宣言的なルーティングやフックを利用する方が適切です。

これらのAPIやユーティリティを適切に理解し、それぞれの目的に合致した方法で使用することが、React Router v7 を用いた開発の効率と品質を高める上で重要です。

## **結論 (Conclusion)**

本コーディング規約は、React Router v7 を使用するプロジェクトにおいて、一貫性、保守性、そしてベストプラクティスの遵守を促進することを目的として作成されました。React Router v7 は、宣言的モード、データモード、フレームワークモードという3つの主要な利用モードを提供し、それぞれが異なるユースケースと機能セットを持っています。プロジェクトの初期段階で、アプリケーションの規模、データ要件、サーバーサイドレンダリングの必要性、チームの習熟度などを総合的に考慮し、最適なモードを選択することが極めて重要です。この選択は、アプリケーションのアーキテクチャ全体に影響を及ぼし、将来の開発効率や拡張性を左右します。

ルーティング定義においては、選択したモードに応じた規約（フレームワークモードの app/routes.ts、データモードの createBrowserRouter とルートオブジェクト、宣言的モードの \<Routes\>/\<Route\>）に従い、パスセグメントの利用（動的、オプショナル、スプラット）やファイルシステムベースルーティング（フレームワークモード）の指針を遵守することが求められます。

ナビゲーションに関しては、\<Link\> と \<NavLink\> の適切な使い分け、useNavigate の限定的な使用、そして \<Form\> や redirect ユーティリティの正しい活用が、ユーザーエクスペリエンスとアクセシビリティの向上に繋がります。

データフェッチングとミューテーションは、特にデータモードとフレームワークモードの中核機能です。loader によるデータ取得、action によるデータ変更、そして fetcher を利用した非ナビゲーション的なデータ操作は、コンポーネントからデータ関連の関心事を分離し、コードの可読性とテスト容易性を高めます。自動再検証や shouldRevalidate による制御も、効率的なデータ管理に貢献します。

エラー処理は、ErrorBoundary（フレームワークモード）や errorElement（データモードの可能性）、useRouteError フック、そして loader/action 内での意図的なエラーレスポンスのスローを通じて、堅牢なアプリケーションを構築するための鍵となります。サーバーサイドエラー報告も、問題の早期発見と解決に役立ちます。

コード分割と遅延読み込みは、フレームワークモードの自動機能や、lazy プロパティの活用により、アプリケーションの初期ロードパフォーマンスを大幅に改善します。

最後に、ルート保護は loader を利用した認証ベースのリダイレクトで実現し、CSPと nonce の設定はXSS攻撃からの防御に貢献します。

本規約が、React Router v7 を用いた高品質なウェブアプリケーション開発の一助となることを期待します。技術の進化やプロジェクトの特性に応じて、本規約を適宜見直し、更新していくことが推奨されます。

## **付録 (Appendix)**

### **参考資料 (References)**

* React Router v7 ドキュメント日本語版: [https://react-router-docs-ja.techtalk.jp/](https://react-router-docs-ja.techtalk.jp/) 1  
  * 本規約の大部分は、上記ドキュメント内の情報（スニペットとして提供された範囲）に基づいて作成されています。詳細なAPI仕様や最新情報については、常に公式ドキュメントを参照してください。  
* (その他、規約作成中に参照した可能性のある外部の標準的なドキュメントや記事があれば記載)  
  * Content Security Policy (CSP) \- MDN Web Docs  
  * React Suspenseに関するドキュメント \- React公式サイト

#### **引用文献**

1. React Router v7 ドキュメント 日本語版, 5月 24, 2025にアクセス、 [https://react-router-docs-ja.techtalk.jp/](https://react-router-docs-ja.techtalk.jp/)  
2. Routes \- React Router v7 ドキュメント 日本語版, 5月 24, 2025にアクセス、 [https://react-router-docs-ja.techtalk.jp/api/components/Routes](https://react-router-docs-ja.techtalk.jp/api/components/Routes)  
3. ルートオブジェクト \- React Router v7 ドキュメント 日本語版, 5月 24, 2025にアクセス、 [https://react-router-docs-ja.techtalk.jp/start/data/route-object](https://react-router-docs-ja.techtalk.jp/start/data/route-object)  
4. Await \- React Router v7 ドキュメント 日本語版, 5月 24, 2025にアクセス、 [https://react-router-docs-ja.techtalk.jp/api/components/Await](https://react-router-docs-ja.techtalk.jp/api/components/Await)  
5. react-router-docs-ja.techtalk.jp, 5月 24, 2025にアクセス、 [https://react-router-docs-ja.techtalk.jp/api](https://react-router-docs-ja.techtalk.jp/api)  
6. 1月 1, 1970にアクセス、 [https://react-router-docs-ja.techtalk.jp/api/hooks/useRouteError](https://react-router-docs-ja.techtalk.jp/api/hooks/useRouteError)  
7. 1月 1, 1970にアクセス、 [https://react-router-docs-ja.techtalk.jp/route/error-element](https://react-router-docs-ja.techtalk.jp/route/error-element)  
8. ナビゲーション \- React Router v7 ドキュメント 日本語版, 5月 24, 2025にアクセス、 [https://react-router-docs-ja.techtalk.jp/start/framework/navigating](https://react-router-docs-ja.techtalk.jp/start/framework/navigating)  
9. redirect \- React Router v7 ドキュメント 日本語版, 5月 24, 2025にアクセス、 [https://react-router-docs-ja.techtalk.jp/api/utils/redirect](https://react-router-docs-ja.techtalk.jp/api/utils/redirect)  
10. ルートモジュール \- React Router v7 ドキュメント 日本語版, 5月 24, 2025にアクセス、 [https://react-router-docs-ja.techtalk.jp/start/framework/route-module](https://react-router-docs-ja.techtalk.jp/start/framework/route-module)  
11. エラー境界 \- React Router v7 ドキュメント 日本語版, 5月 24, 2025にアクセス、 [https://react-router-docs-ja.techtalk.jp/how-to/error-boundary](https://react-router-docs-ja.techtalk.jp/how-to/error-boundary)  
12. 1月 1, 1970にアクセス、 [https://react-router-docs-ja.techtalk.jp/how-to/auth](https://react-router-docs-ja.techtalk.jp/how-to/auth)  
13. データローディング \- React Router v7 ドキュメント 日本語版, 5月 24, 2025にアクセス、 [https://react-router-docs-ja.techtalk.jp/start/framework/data-loading](https://react-router-docs-ja.techtalk.jp/start/framework/data-loading)  
14. データローディング \- React Router v7 ドキュメント 日本語版, 5月 24, 2025にアクセス、 [https://react-router-docs-ja.techtalk.jp/start/data/data-loading](https://react-router-docs-ja.techtalk.jp/start/data/data-loading)  
15. 1月 1, 1970にアクセス、 [https://react-router-docs-ja.techtalk.jp/api/components/Route](https://react-router-docs-ja.techtalk.jp/api/components/Route)  
16. react-router-docs-ja.techtalk.jp, 5月 24, 2025にアクセス、 [https://react-router-docs-ja.techtalk.jp/start/declarative/routing](https://react-router-docs-ja.techtalk.jp/start/declarative/routing)